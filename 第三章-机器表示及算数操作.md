# 第三章-机器表示及算数操作

## 1、程序编码

**编译程序**

  对于一个 C 程序，有两个文件 p1.c 和 p2.c，我们在linux下用如下命令编译程序：
  
    linux> gcc -Og -o p1.c p2.c
      
  编译选项 -Og 告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化等级。使用较高的优化级别会导致代码出现严重变形，使得产生的机器代码和原始代码间的关系非常难以理解。
  在编译的过程中，编译器会经过以下几个步骤：
  
- 1、首先， 预处理器扩展源代码，插入所有用 include 命令指定的文件，并扩展所有用 #define 声明指定的宏。

- 2、其次，编译器产生两个源文件的汇编代码，名字分别为 pl. p2.s。

- 3、接下来，汇编器会将汇编代码转化成二进制目标代码文件 pl.a p2.o 目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。

- 4、最后，链接器将两个目标代码文件与实现库函数（例如 printf) 的代码合并，并产生最终的可执行代码文件（由命令行指示符 -op 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

如果我们需要观察编译器对 C 程序的编译结果，可以使用如下命令：
  
    linux> gcc -Og -S p1.c
    
  其中，-S 表示对程序仅执行到编译的步骤，生成汇编文件 p1.s。此外，如果如果希望产生目标代码，可以将参数 —S 改成 -c，编译得到 .o 文件。它是二进制格式的，可以使用反汇编器进行查看。相应的命令是：
  
    linux> objdump -d p1.o
    
  最后，生成可执行代码则只需要将 -S 改成 —o，注意，生成可执行代码需要对一组目标代码文件运行链接器，而这一组目标代码中必须包含一个 main 函数。

**机器级代码**

  对于机器级编程来说，其中两种抽象尤为重要：
  
- 第一种是由指令体系结构或指令集架构来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式等，将程序的行为描述好像每条指令都是顺序执行的。

- 第二种抽象是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

  对一个 C 程序进行编译，得到 .s 文件后，其中包含一些指导汇编器和连接器工作的伪指令，这些信息均以 . 开头，我们通常可以忽略它们。
  
  ![image](https://user-images.githubusercontent.com/56211928/142836161-53523218-edd2-48aa-8a69-c596ad86feae.png)
  
 **数据格式**
 
   Intel用术语“字”表示 16 位数据类型，相应的，对 32 位数称“双字”，对64位数称“四字”。x86-64中，long 实现位64位，其他数据类型的大小如下图：
   
   ![image](https://user-images.githubusercontent.com/56211928/142836787-c9cfbbe0-a4c3-44ea-ab7e-4f52d6fe1651.png)
  
 **访问信息**
 
  一个 x86-64 的 CPU 包含一组 16 个存储 64 位值的通用寄存器，这些寄存器用来存储整数或指针。大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，movb 表示传送字节，相应的，movw、movl、movq 分别表示传送 16 位字、32 位双字以及 64 位 4 字。各个寄存器名称以及使用规则如下图：
  
  ![image](https://user-images.githubusercontent.com/56211928/142837662-818c50fa-523c-4377-9982-fc5a6ff3b272.png)

  


  

