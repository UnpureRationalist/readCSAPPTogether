# 第三章-机器表示及算数操作

## 1、程序编码

**编译程序**

  对于一个 C 程序，有两个文件 p1.c 和 p2.c，我们在linux下用如下命令编译程序：
  
    linux> gcc -Og -o p1.c p2.c
      
  编译选项 -Og 告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化等级。使用较高的优化级别会导致代码出现严重变形，使得产生的机器代码和原始代码间的关系非常难以理解。
  在编译的过程中，编译器会经过以下几个步骤：
  
- 1、首先， 预处理器扩展源代码，插入所有用 include 命令指定的文件，并扩展所有用 #define 声明指定的宏。

- 2、其次，编译器产生两个源文件的汇编代码，名字分别为 pl. p2.s。

- 3、接下来，汇编器会将汇编代码转化成二进制目标代码文件 pl.a p2.o 目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。

- 4、最后，链接器将两个目标代码文件与实现库函数（例如 printf) 的代码合并，并产生最终的可执行代码文件（由命令行指示符 -op 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

如果我们需要观察编译器对 C 程序的编译结果，可以使用如下命令：
  
    linux> gcc -Og -S p1.c
    
  其中，-S 表示对程序仅执行到编译的步骤，生成汇编文件 p1.s。此外，如果如果希望产生目标代码，可以将参数 —S 改成 -c，编译得到 .o 文件。它是二进制格式的，可以使用反汇编器进行查看。相应的命令是：
  
    linux> objdump -d p1.o
    
  最后，生成可执行代码则只需要将 -S 改成 —o，注意，生成可执行代码需要对一组目标代码文件运行链接器，而这一组目标代码中必须包含一个 main 函数。

**机器级代码**

  对于机器级编程来说，其中两种抽象尤为重要：
  
- 第一种是由指令体系结构或指令集架构来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式等，将程序的行为描述好像每条指令都是顺序执行的。

- 第二种抽象是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。


对一个 C 程序进行编译，得到 .s 文件后，其中包含一些指导汇编器和连接器工作的伪指令，这些信息均以 . 开头，我们通常可以忽略它们。
  
  ![image](https://user-images.githubusercontent.com/56211928/142836161-53523218-edd2-48aa-8a69-c596ad86feae.png)
  
 **数据格式**
 
   Intel用术语“字”表示 16 位数据类型，相应的，对 32 位数称“双字”，对64位数称“四字”。x86-64中，long 实现位64位，其他数据类型的大小如下图：
   
   ![image](https://user-images.githubusercontent.com/56211928/142836787-c9cfbbe0-a4c3-44ea-ab7e-4f52d6fe1651.png)
  
 **寄存器表**
 
  一个 x86-64 的 CPU 包含一组 16 个存储 64 位值的通用寄存器，这些寄存器用来存储整数或指针。大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，movb 表示传送字节，相应的，movw、movl、movq 分别表示传送 16 位字、32 位双字以及 64 位 4 字。各个寄存器名称以及使用规则如下图：
  
  ![image](https://user-images.githubusercontent.com/56211928/142837662-818c50fa-523c-4377-9982-fc5a6ff3b272.png)
  
**操作数编码规则**

  各种不同的操作数可分为 3 类：
  
- 立即数：在 $ 符号后跟一个整数，eg：$-577，$0x1F
- 寄存器：表示某个寄存器中的内容，直接用寄存器的名称表示
- 内存引用：根据计算出来的地址访问内存位置，通常使用使用“()”表示（注意：leaq 指令除外）

一个通用的内存引用寻址方式的格式为
  
    Imm(rb, ri, s)
    
  包含 4 部分，一个立即数偏移，一个基址寄存器 rb，一个变址寄存器 ri，一个比例因子 s。有效地址为：Imm + R[rb] + R[ri] * s。
  
  各种寻址方式的表示如下图：
  
  ![image](https://user-images.githubusercontent.com/56211928/142839509-aedd6fdb-e370-4d43-b387-4c7da9fce2e8.png)
  
  
## 2、数据传送指令

传送指令将数据从一个位置复制到另一个位置。最简单的传送指令的表示如下图：

![image](https://user-images.githubusercontent.com/56211928/142840186-fbcf66c1-f6ad-430c-b033-a9413a698d46.png)

零扩展传送指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142840742-2e00f58a-999a-4d62-b371-7ad491d85de4.png)

符号扩展指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142840844-f9eb1744-3839-45dd-9915-8a1bf5d00806.png)

压栈弹栈指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142840896-3c72e880-507a-473c-b698-cc6cb60b2151.png)

几点需要特殊注意的地方：

- 传送指令的两个操作数不能都指向内存位置。
- movl 指令以寄存器为目的时，会把高位 4 字节设置为0。其等价于 movzlq 指令，不过可以看到，其实并没有这样的指令。
- 常规的 movq 指令的源操作数是立即数时，其只能表示为 32 位补码数字，然后符号扩展为 64 位。movabsq 指令能以任意 64 位立即数作为源操作数，但只能以寄存器作为目的。
- x86-64 中，栈向低地址方向增长，压栈总是减小栈指针（%rsp）的值，%rsp 寄存器中的地址始终指向栈顶。


## 3、算数和逻辑操作

大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有 leaq 没有其他大小的变种）。例如，指令类 ADD 由四条加法指令组成： addb addw addl addq, 分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。如下图：

![image](https://user-images.githubusercontent.com/56211928/142843222-cef1b236-dfc3-4a19-a2b5-7099bc61d6a6.png)

特殊的算数操作指令如下图:

![image](https://user-images.githubusercontent.com/56211928/142843422-42d8a611-200c-4f19-8fb1-21c2be0d84fc.png)

几点需要特殊注意的地方：

- leaq 指令实际上是 movq 指令的变形，它的指令格式看似是从内存读数据到寄存器，但实际上并没有访问内存。编译器经常利用 leaq 指令完成一些简单的算术计算。eg：leaq 7(%rdx, %rdx, 4), %rax，是将 %rax 的值设置为 5x + 7，其中 x 是 %rdx 的值。
- 对于二元操作来讲，其运算顺序和直觉相反，其第一操作数为第二源操作数，第二操作数既是第一源操作数，也是目的操作数。eg：subq %rax, %rdx，结果是 %rdx = %rdx - %rax。
- 对于移位指令，移位量既可以是一个立即数，也可以放在单字节寄存器 %cl 中。对于 w 位长的数值进行操作时，移位量是由 %cl 中低 m 位决定的，其中 2<sup>m</sup> = w。





  


  

