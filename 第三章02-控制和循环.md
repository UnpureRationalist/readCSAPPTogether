# 控制和循环

## 1、控制

**条件码**

除了整数寄存器，CPU还维护一组单个位的条件码寄存器，它们描述了最近的算数或逻辑操作的属性。通过检测这些寄存器来执行条件分支。常用的条件码有：进位标志CF、零标志ZF、符号标志SF、溢出标志OF。基本上算数和移位指令都会改变条件码，而还有两类指令只改变条件码而不修改任何寄存器。
CMP 指令根据两个操作数之差来设置条件码，TEST 指令与 AND 行为相同。如下图：

![image](https://user-images.githubusercontent.com/56211928/142853714-187816cf-f3f8-4a3f-add2-7ca1bfc4671e.png)

条件码寄存器通常不会直接读取，常用的使用方法有 3 种：

- 根据条件码的某种组合，将一个字节设置为 0 或 1，对应于 set 指令。
- 根据条件跳转到程序的某个其他部分，对应 jmp 指令。
- 有条件的传送数据，对应 cmov 指令。

**set指令**

SET 指令的目的操作数是低位单字节寄存器之一，或是一个字节的内存位置。如果要得到 32 或 64 位的结果，必须对寄存器高位清零。SET 类指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142854849-8f1bf03b-2be7-48c9-aef4-d4261996531b.png)

**jmp指令**

跳转指令会导致执行切换到程序中一个新的位置。汇编代码中，跳转目的地通常用一个标号（label）来指明。在产生目标代码文件时，汇编器会确定所有代标号指令的位置，并将跳转目标地址编码为跳转指令的一部分。jmp类指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142856267-a8077891-9a40-4347-a679-e0da8f5a4c38.png)

跳转指令有几种不同的编码，最常用的是相对 PC 的跳转，它们会根据目标指令的地址与**紧跟在跳转指令后面的那条指令的地址之间**的差作为编码。另外一种方法是给出“绝对”地址，用 4 个字节直接指定地址目标。

**利用jmp指令实现条件分支**

C 语言中的 if-else 语句的通用形式模板如下：

![image](https://user-images.githubusercontent.com/56211928/142857232-1e39671b-61a5-43f4-8a56-aba18eb14383.png)

这里 test-expr 是一个整数表达式，它的取值为 0(解释为“假")或者为非 0( 解释为“真")。两个分支语句中 (then-statement else-statement) 只会执行一个。对于这种通用形式，汇编实现通常会使用下面这种形式：

![image](https://user-images.githubusercontent.com/56211928/142857353-f8e31705-03d3-44a4-ad31-3321708c18a4.png)

也就是，汇编器为 then-statement else-statement 产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。


