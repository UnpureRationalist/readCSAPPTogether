# 控制和循环

## 1、控制

**条件码**

除了整数寄存器，CPU还维护一组单个位的条件码寄存器，它们描述了最近的算数或逻辑操作的属性。通过检测这些寄存器来执行条件分支。常用的条件码有：进位标志CF、零标志ZF、符号标志SF、溢出标志OF。基本上算数和移位指令都会改变条件码，而还有两类指令只改变条件码而不修改任何寄存器。
CMP 指令根据两个操作数之差来设置条件码，TEST 指令与 AND 行为相同。如下图：

![image](https://user-images.githubusercontent.com/56211928/142853714-187816cf-f3f8-4a3f-add2-7ca1bfc4671e.png)

条件码寄存器通常不会直接读取，常用的使用方法有 3 种：

- 根据条件码的某种组合，将一个字节设置为 0 或 1，对应于 set 指令。
- 根据条件跳转到程序的某个其他部分，对应 jmp 指令。
- 有条件的传送数据，对应 cmov 指令。

---
**set指令**

SET 指令的目的操作数是低位单字节寄存器之一，或是一个字节的内存位置。如果要得到 32 或 64 位的结果，必须对寄存器高位清零。SET 类指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142854849-8f1bf03b-2be7-48c9-aef4-d4261996531b.png)

---
**jmp 指令**

跳转指令（jmp）会导致执行切换到程序中一个新的位置。汇编代码中，跳转目的地通常用一个标号（label）来指明。在产生目标代码文件时，汇编器会确定所有代标号指令的位置，并将跳转目标地址编码为跳转指令的一部分。jmp类指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142856267-a8077891-9a40-4347-a679-e0da8f5a4c38.png)

跳转指令有几种不同的编码，最常用的是相对 PC 的跳转，它们会根据目标指令的地址与**紧跟在跳转指令后面的那条指令的地址之间**的差作为编码。另外一种方法是给出“绝对”地址，用 4 个字节直接指定地址目标。

**利用 jmp 指令实现条件分支**

C 语言中的 if-else 语句的通用形式模板如下：

![image](https://user-images.githubusercontent.com/56211928/142857232-1e39671b-61a5-43f4-8a56-aba18eb14383.png)

这里 test-expr 是一个整数表达式，它的取值为 0(解释为“假")或者为非 0( 解释为“真")。两个分支语句中 (then-statement else-statement) 只会执行一个。对于这种通用形式，汇编实现通常会使用下面这种形式：

![image](https://user-images.githubusercontent.com/56211928/142857353-f8e31705-03d3-44a4-ad31-3321708c18a4.png)

也就是，汇编器为 then-statement else-statement 产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。

考虑如下一个比较 x 和 y 的大小的例子。其中，如果 x < y，返回 y - x，并且 lt_cnt++，否则，返回 x - y，并且 ge_cnt++。

![image](https://user-images.githubusercontent.com/56211928/142858531-55d4c7c6-6658-41f9-ab60-37ba3c147dc8.png)

---
**cmov 指令**

条件传送指令（cmov）相较于 jmp 指令有更高的执行速度。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性，因为它对流水线更友好，不会造成转移导致的流水线时延。cmov 类指令如下图：

![image](https://user-images.githubusercontent.com/56211928/142859166-d45615d0-ee6c-4343-8598-47ba75bb892d.png)


**利用 cmov 指令实现条件传送**

对于条件传送指令，处理器无需预测测试结果即可以执行条件传送。
考虑如下的条件表达式和赋值的通用形式：

![image](https://user-images.githubusercontent.com/56211928/142859675-68826cb4-7040-431c-a652-f07e47850733.png)

用条件控制转移的标准方法来编译这个表达式会得到如下形式：

![image](https://user-images.githubusercontent.com/56211928/142859740-53d8789c-a9c2-4937-a391-66d4bb583ab9.png)

基于条件传送的代码，会对 then-expr 和 else-expr 都求值，最终值的选择基于对 test-expr 的求值。可以用下而的抽象代码描述：

![image](https://user-images.githubusercontent.com/56211928/142859844-285e191c-ca44-4fd5-a071-8f8ea0d9f7f5.png)

这个序列中的最后一条语句是用条件传送实现的，只有当测试条件满足时， vt 的值才会被复制到 v 中。

仍考虑一个比较 x 和 y 的大小的例子。其中，如果 x < y，返回 y - x，否则，返回 x - y。注意到和上个例子不同的是，它不需要修改 lt_cnt 或 ge_cnt 的值，可以使用条件传送指令来实现。

![image](https://user-images.githubusercontent.com/56211928/142860376-841a0c52-ba97-4a3f-8a23-280838f33d47.png)

注意，不是所有的表达式都可以用条件传送来编译。因为无论测试结果如何，这种指令都会对 then-expr else-expr 都求值，但如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为。

---
## 2、循环

C 语言中提供了 do-while、while 和 for 三种循环结构。汇编中没有相应的指令，可以利用条件测试和跳转组合起来实现循环的效果。

---
**do-while 循环**

do-while 语句的通用形式如下：

![image](https://user-images.githubusercontent.com/56211928/142862150-4e6fb118-79a2-464d-a1a2-e21b99a7dcf5.png)

相应汇编实现通常会使用下面这种形式：

![image](https://user-images.githubusercontent.com/56211928/142862390-27032d22-c823-4f95-8c93-928173f27e9f.png)

一个用 do-while 循环来计算阶乘的示例如下：

![image](https://user-images.githubusercontent.com/56211928/142862627-02746af2-d520-4f38-933e-b90e77d991cb.png)

---
**while 循环**

while 语句的通用形式如下：

![image](https://user-images.githubusercontent.com/56211928/142862998-5bfdb115-0db4-4ee7-851a-48894ec782ef.png)

有很多种方法将 while 循环翻译成机器代码，GCC 提供两种不同的翻译方法。
第一种翻译方法为跳转到中间，它执行一个无条件跳转到循环结尾处的测试，如下图：

![image](https://user-images.githubusercontent.com/56211928/142863468-38ef7adf-3d8e-4390-9cf5-8c58dada5a9f.png)

第二种翻译方法，称之为 guarded-do，首先进行条件判断，如果初始条件不成立就跳过循环，否则把代码转换成 do-while 形式。通常用较高优化等级编译时，GCC 会采取这种策略。这种翻译方式的汇编伪代码如下图：

![image](https://user-images.githubusercontent.com/56211928/142864023-7caab07a-a919-4e55-8005-04de29c7d845.png)

以下分别是使用跳转到中间和 guarded-do 翻译方法执行 while 循环的示例：

- 跳转到中间

![image](https://user-images.githubusercontent.com/56211928/142864286-c112d7cb-fb93-46df-81fd-76fe13032c8f.png)

- guarded-do

![image](https://user-images.githubusercontent.com/56211928/142864199-e2d2dc58-cb46-435c-835a-05cec8f49c02.png)
![image](https://user-images.githubusercontent.com/56211928/142864217-87c5d0c2-473a-4b46-bbb8-50f30528cdd9.png)

---
**for 循环**

for 循环的通用格式如下：

![image](https://user-images.githubusercontent.com/56211928/142865425-c68f93e6-0de9-4f14-b503-52d661c1b9e2.png)

这样一个循环的行为与下面这段使用 while 循环的代码的行为一样：

![image](https://user-images.githubusercontent.com/56211928/142865496-e9393c65-6bff-4c3c-8cf8-0c23fbca5d91.png)

GCC for 循环产生的代码是 while 循环的两种翻译之一，这取决于优化的等级。此处不再赘述。

---
**switch 语句**

switch（开关）语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了代码的可读性，而且通过使用跳转表这种数据结构使得实现加高效。跳转表是一个数组，表项是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和一组很长的 if-else，使用跳转表的优点是执行开关语句的时间与开关情况的数最无关。

如下的 switch 例子，数组（跳转表）包含7个表项，每个都是一个代码块地址。这些位置由代码中的标号定义，在 jt 的表项中由代码指针表明（由标号加上‘&&’前缀组成）

![image](https://user-images.githubusercontent.com/56211928/142867511-18c797dc-5158-470d-8bea-aaee7e80aeb9.png)
![image](https://user-images.githubusercontent.com/56211928/142867531-f31caa58-7a66-47f6-ab55-74a5c73b0ce4.png)

在 C 和汇编代码中，根据 index 的值，有 5 个不同的跳转位置：loc A(在汇编代码中标识为 .L3), loc B(.L5), loc c(.L6), loc o(.L7) loc def(.L8), 最后一个是默认的目的地址。每个标号都标识一个实现某个情况分支的代码块。注意汇编代码中的 jmp 指令的操作数有前缀 \*，表明这是一个间接跳转，操作数指定一个内存位置。汇编代码的跳转表如下图：

![image](https://user-images.githubusercontent.com/56211928/142867889-34505681-36d7-4bdd-b158-7fc34431749c.png)

总之，跳转表可以理解为，利用一个数组存放 switch 每种可能的代码段标号，通过判断结果得到数组索引，并根据数组的索引执行相应的代码段。

以下是一个根据 switch 语句汇编代码翻译 C 代码的习题。可以看到，汇编代码的顺序和 C 代码的顺序未必完全一致，必须明确理解跳转表的含义，并根据跳转表的内容来具体分析：

![IMG_20211122_212007_edit_483891006750120](https://user-images.githubusercontent.com/56211928/142869092-f5312181-417b-42e5-b96a-b780486f2759.jpg)

