# 对5、6章书中部分示例的重现与分析

书中 5、6 章通过一系列的示例代码分析了程序在 Inter Core I7 HasWell 上的执行效果。

以下几段代码在华为 MateBook D 15 上运行，CPU 型号为 Inter(R) Core(TM) i5-10210U CPU @ 1.60GHZ 2.11GHZ。一级缓存 256KB，二级缓存 1024KB，三级缓存 6144KB。

在执行书中示例代码的过程中，发现有些结果与书中结论误差较大，甚至有些结果显得不可思议。以下通过几个实验具体分析：

## 1、书中第五章程序优化示例的复现

`程序优化.cpp`对书中 P347 - P349 的代码执行若干次优化，将结果输出到 result.txt 文件中，并利用`calCPE.m`拟合 CPE，由于时间关系，仅分析了整数乘法，得到结果如下（括号中为书中结果）：

![image](https://user-images.githubusercontent.com/56211928/144714756-1d40a9db-2e64-46bb-bb44-69c1b9d01f00.png)

存在以下几个问题

- 对于 combine3，书中的结论是由于函数调用内部的分支可以被高度预测，故这个优化没有太大的效果。但在本地执行却发现这个优化的效果很显著，可能由于本地计算机 CPU 的分支预测做的不太好。
- 对于 combine4，该代码性能在书中得到了很好的提升，但本地执行时发现程序性能并没有提升，可能因为本地计算机 CPU 对内存读写的性能较好，在数据量较小的情况下不会产生额外的数据开销。
- 对于 combine5，书中的结论是由于 combine4 的程序已经达到了延迟界限，故 combine5 的优化没有效果。但这个优化却在本地计算机上有不错的效果，可能还是因为本地计算机 CPU 的分支预测问题，使得循环开销仍然是影响程序性能的关键因素之一。

整个实验，由于对本地计算机 CPU 的具体数据不清楚，难以估计每个操作的延迟界限和吞吐量界限。但值得欣慰的是，一系列的优化过程虽然和书中结论有些不符，但还是能够看到优化对程序性能确实起到不错的改进效果。

## 2、书中第六章存储器山的复现

`存储器山.cpp`对书中 P444 的代码进行复现（使用 O1 级优化），将结果输出到 result.txt 文件中，并利用`Memory_mountain.m`计算吞吐量，得到的结果和书中结论差异甚大，请看如下分析：

书中的存储器山如下：

![image](https://user-images.githubusercontent.com/56211928/144718460-b12c7d24-5aed-4507-b1d3-23193d9a9c34.png)

本地计算机得到的存储器山如下：

![image](https://user-images.githubusercontent.com/56211928/144718662-7dbb2909-9ab4-46a2-905a-2a9f35415e52.png)

书中的存储器山可以从数据量和步长两个方向看到明显的曲面，而本地计算机得到的存储器山只在步长一个方向存在曲面。这说明吞吐量只与步长有关，和数据量大小无关。对此结果的个人猜测如下：

- CPU 利用良好的数据预取机制，将接下来需要的数据已经在 L2 cache 中准备好，因此数据量方向上吞吐量保持不变。
- 由于步长的增长，对 L1 cache 的换入换出逐渐频繁，因此该方向上吞吐量下降。

