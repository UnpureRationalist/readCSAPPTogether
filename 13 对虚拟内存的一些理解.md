# 对虚拟内存的一些理解

我们知道，Linux 会为每个进程创建一个相同的内存映射，如下图：

![image](https://user-images.githubusercontent.com/56211928/148564276-27dd0240-1fb8-4bde-8109-16974ba9f7e6.png)

虚拟内存实际上由页表控制，虚拟内存地址对应页表的索引，该索引下的表项是虚拟内存所在的实际物理地址。这个物理地址可能存在于磁盘上，也可能存在于主存中，还可能不存在于任何位置。当 cpu 需要访存时，指令中给出的是虚拟内存地址，由集成在 cpu 芯片上的地址转换器 MMU 负责将虚拟地址转换为实际的物理地址。

程序加载时，进程的代码和数据实际上并不进入主存，而是在进程页表上建立虚拟地址到物理地址映射关系，当 cpu 实际需要访存时，会发生缺页异常，此时才会将代码或数据调入主存。书上所讲的内容基本上是当进程读数据时的情况，但很少涉及进程写内存的情况。以下通过理论 + 实验分析，当程序写内存时发生的情况。

Linux 下可以通过 top 和 pmap 命令查看进程占用内存情况。

## 1、对全局变量的写内存

未初始化的全局变量在可执行文件中存储在 .bss 段，但其实这个段仅仅是一个占位符，其中的数据并不真正储存在磁盘上。这个部分的数据在进程加载时被映射到匿名文件，使用时请求二进制零。

### 定义全局变量后不使用

定义一个未初始化的全局变量后，如果运行该程序，那么这些数据会被载入到虚拟内存，但如果不使用，则这些数据会存在磁盘上的匿名文件中，但不会载入主存。

![image](https://user-images.githubusercontent.com/56211928/148570564-48221269-60b1-4c70-92a4-57f35138365a.png)

这段代码全局变量 a[10000000] 占用 40M 内存，运行后，内存占用情况是，虚拟内存约 40M，实际驻留内存较小。

![image](https://user-images.githubusercontent.com/56211928/148630599-d5ef8f29-339e-4638-a6ef-3f358181286a.png)

### 定义全局变量后写入

如果对未初始化的全局变量写入，则这些数据会从虚拟内存加入到主存中。

![image](https://user-images.githubusercontent.com/56211928/148630513-e5a56d50-422c-4b72-9f96-d7c444d50a88.png)

可以看到，该进程所占用的虚拟内存和主存都大约 40M，可知数组 a 已经在主存中。

![image](https://user-images.githubusercontent.com/56211928/148630568-bae555dd-5846-40f7-881a-d1305c74172f.png)

---

## 2、对局部变量的写内存

局部变量被存储在栈段，这个段是自动伸展的。当用户访问的虚拟地址越过栈基址寄存器 ESP 中的地址时，内核会在处理缺页异常的时候将自动将这个段增大。同样，栈的释放也是自动进行的。

### 定义局部变量不使用

如果定义一个局部变量数组后，不使用，在汇编代码中仅仅会有对 ESP 寄存器的更新操作，但数组实际上不会被载入到虚拟内存，更不会在主存。

![image](https://user-images.githubusercontent.com/56211928/148631021-783cac9c-a0ce-4fbd-b30f-9500c3b35feb.png)

该程序中，a[1000000] 会占用 4M 内存，虽然此时该程序所占用的虚拟内存也大约是 4M，但这 4M 内存并非是数组 a 所占用的。

![image](https://user-images.githubusercontent.com/56211928/148630967-5cf92dd6-aad4-4ac8-8873-b2c5951dee0f.png)

### 定义局部变量仅操作最低地址

如果定义一个局部变量数组后，仅仅向首元素对应的位置写数据，即操作该数组最低地址。此时，操作系统会将整个新开辟的数组全部载入到虚拟内存，但只有首元素那部分数据载入到主存。

![image](https://user-images.githubusercontent.com/56211928/148631242-d109b438-a6c0-4703-b4fc-0b982d5cdece.png)

这时，虚拟内存大小为 8M 左右，多出的 4M 表明该数组全部都被载入到虚拟内存，但使用主存的大小几乎没有变化。

![image](https://user-images.githubusercontent.com/56211928/148631237-03533171-9b6f-49df-a268-e0343c242b31.png)

### 定义局部变量全部使用

如果定义一个局部变量数组后，操作其全部的位置，则该数组将全部载入到主存。

![image](https://user-images.githubusercontent.com/56211928/148631390-6caf29de-70ac-42b4-bdc0-d157423d2798.png)

此时，虚拟内存和上面的情况相同，但占用主存空间约多出 4M，可知该数组已经载入到主存。

![image](https://user-images.githubusercontent.com/56211928/148631382-73c65551-6803-46f5-add1-3dbd4596553d.png)

---

## 3、对栈初始化的分析

虽然栈的初始化是请求二进制 0 的，但由于栈会被重复使用，因此不能认为在栈上申请的变量初始值是 0。

![image](https://user-images.githubusercontent.com/56211928/148633533-e516bf45-069b-4a05-942b-318a2a9db459.png)

在 test1 中，a 共有 1000000 个元素，且 a[i] = i，在 test2 中，a 有 2000000 个元素，但并未初始化。此时直接对 a 中的 1000000 - 1000010 的元素进行输出，结果为 0 - 9，恰好是 test1 中 a 对应地址的值，这说明在 test1 结束后，栈内存并未被立即释放。此时，再对 test2 中 a 数组 0 - 10 的元素进行输出，此时，由于栈是请求二进制 0 的，且这些地址之前并没有被使用过，所以输出全 0。

![image](https://user-images.githubusercontent.com/56211928/148633693-efa3e83e-b5de-42de-9fda-ee90e37a5172.png)

