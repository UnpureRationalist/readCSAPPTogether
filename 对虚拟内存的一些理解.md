# 对虚拟内存的一些理解

我们知道，Linux 会为每个进程创建一个相同的内存映射，如下图：

![image](https://user-images.githubusercontent.com/56211928/148564276-27dd0240-1fb8-4bde-8109-16974ba9f7e6.png)

虚拟内存实际上由页表控制，虚拟内存地址对应页表的索引，该索引下的表项是虚拟内存所在的实际物理地址。这个物理地址可能存在于磁盘上，也可能存在于主存中，还可能不存在于任何位置。当 cpu 需要访存时，指令中给出的是虚拟内存地址，由集成在 cpu 芯片上的地址转换器 MMU 负责将虚拟地址转换为实际的物理地址。

程序加载时，进程的代码和数据实际上并不进入主存，而是在进程页表上建立虚拟地址到物理地址映射关系，当 cpu 实际需要访存时，会发生缺页异常，此时才会将代码或数据调入主存。书上所讲的内容基本上是当进程读数据时的情况，但很少涉及进程写内存的情况。以下通过理论 + 实验分析，当程序写内存时发生的情况。

Linux 下可以通过 top 和 pmap 命令查看进程占用内存情况。

## 1、对全局变量的写内存

未初始化的全局变量在可执行文件中存储在 .bss 段，但其实这个段仅仅是一个占位符，其中的数据并不真正储存在磁盘上。这个部分的数据在进程加载时被映射到匿名文件，使用时请求二进制零。

### 定义全局变量后不使用

定义一个未初始化的全局变量后，如果运行该程序，那么这些数据会被载入到虚拟内存，但如果不使用，则这些数据会存在磁盘上的匿名文件中，但不会载入主存。

![image](https://user-images.githubusercontent.com/56211928/148570564-48221269-60b1-4c70-92a4-57f35138365a.png)

这段代码全局变量 a[10000000] 占用 40M 内存，运行后，内存占用情况是，虚拟内存约 40M，实际驻留内存较小。

![image](https://user-images.githubusercontent.com/56211928/148630599-d5ef8f29-339e-4638-a6ef-3f358181286a.png)

### 定义全局变量后写入

如果对未初始化的全局变量写入，则这些数据会从虚拟内存加入到主存中。

![image](https://user-images.githubusercontent.com/56211928/148630513-e5a56d50-422c-4b72-9f96-d7c444d50a88.png)

可以看到，该进程所占用的虚拟内存和主存都大约 40M，可知数组 a 已经在主存中。

![image](https://user-images.githubusercontent.com/56211928/148630568-bae555dd-5846-40f7-881a-d1305c74172f.png)

## 2、对局部变量的写内存

局部变量被存储在栈段，这个段是自动伸展的。当用户访问的虚拟地址越过栈基址寄存器 ESP 中的地址时，内核会在处理缺页异常的时候将自动将这个段增大。

### 定义局部变量不使用

只声明一个函数内部的数组，但

## 3、对栈初始化的分析


