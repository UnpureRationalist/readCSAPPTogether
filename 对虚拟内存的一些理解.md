# 对虚拟内存的一些理解

我们知道，Linux 会为每个进程创建一个相同的内存映射，如下图：

![image](https://user-images.githubusercontent.com/56211928/148564276-27dd0240-1fb8-4bde-8109-16974ba9f7e6.png)

虚拟内存实际上由页表控制，虚拟内存地址对应页表的索引，该索引下的表项是虚拟内存所在的实际物理地址。这个物理地址可能存在于磁盘上，也可能存在于主存中，还可能不存在于任何位置。当 cpu 需要访存时，指令中给出的是虚拟内存地址，由集成在 cpu 芯片上的地址转换器 MMU 负责将虚拟地址转换为实际的物理地址。

程序加载时，进程的代码和数据实际上并不进入主存，而是在进程页表上建立虚拟地址到物理地址映射关系，当 cpu 实际需要访存时，会发生缺页异常，此时才会将代码或数据调入主存。书上所讲的内容基本上是当进程读数据时的情况，但很少涉及进程写内存的情况。以下通过理论 + 实验分析，当程序写内存时发生的情况。

## 1、对全局变量的写内存

未初始化的全局变量在可执行文件中存储在 .bss 段，但其实这个段仅仅是一个占位符，其中的数据并不真正储存在磁盘上。这个部分的数据在进程加载时被映射到匿名文件，使用时请求二进制零。

### 定义全局变量后不使用

定义一个未初始化的全局变量后，如果运行该程序，那么这些数据会被载入到虚拟内存，但如果不使用，则这些数据会存在磁盘上的匿名文件中，但不会载入主存。

![image](https://user-images.githubusercontent.com/56211928/148570564-48221269-60b1-4c70-92a4-57f35138365a.png)

这段代码全局变量 a[10000000] 占用 40M 内存，运行后，内存占用情况是，虚拟内存约 40M，实际驻留内存较小。

![image](https://user-images.githubusercontent.com/56211928/148571124-f06f19a2-7164-498b-9794-452ad51f4443.png)


## 2、对局部变量的写内存

## 3、对栈初始化的分析


