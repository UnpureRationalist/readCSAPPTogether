# 第十一章 & 第十二章

这两章主要是一些编程技术的讲解，因此不做过多的理论记录，仅对其中的部分代码进行分析。

## 1、简单的 web 服务器

这是一个短小但功能齐全的 Web 服务器，该程序的详细注释请看 cpp 下的 tiny.c 文件。

## 2、并发编程中对共享变量加锁的代价

我们想要求解 1 到 n 的和，采用多线程迭代的方式计算，每个线程负责计算加和的一部分，将每次相加的结果记录到全局变量 psum 中，关键代码如下：

![image](https://user-images.githubusercontent.com/56211928/148487995-2bbb3f37-802f-4c5c-893f-d9c9e710ea5e.png)

这段代码对共享变量 psum 的更新前后都要加锁，事实证明，这个加锁的过程开销极大，而且线程数量越多，程序运行的速度反而越慢。如果在全局变量中开辟一个数组，将每个线程的计算中间结果都累加到这个数组的对应位置中，所有线程运算结束后，再将这个数组中的所有元素相加，此时便不需要对共享变量进行加锁，程序运行速度大大提高。

![image](https://user-images.githubusercontent.com/56211928/148489197-7a527285-16c9-4989-a642-761b8da891ef.png)

在本地主机上进行实验，对共享变量加锁的代码运算 2<sup>22</sup> 个数，另一段代码运算 2<sup>31</sup> 个数，结果如下：

![image](https://user-images.githubusercontent.com/56211928/148490674-1b8a0477-8b4c-40cc-b4cc-43e98e59e427.png)

后一个版本的计算量约是前一个版本的 500 倍，但耗时几乎是前一个版本的 1 / 100，可见加锁对整个程序的性能影响很大，尤其是加解锁中间部分运算量较少的程序。另外，可以看到，后一个版本在线程数量为 8 的时候，运行速度最快，刚好本地主机也是 8 核。如果进一步增加线程数，则会因为线程的切换的开销而使性能略微下降。

详细代码请参见 cpp 下的 mutex.cpp 和 psum_array.cpp。

