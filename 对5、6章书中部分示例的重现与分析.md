# 对5、6章书中部分示例的重现与分析

书中 5、6 章通过一系列的示例代码分析了程序在 Inter Core I7 HasWell 上的执行效果。

以下几段代码在华为 MateBook D 15 上运行，CPU 型号为 Inter(R) Core(TM) i5-10210U CPU @ 1.60GHZ 2.11GHZ。一级缓存 256KB，二级缓存 1024KB，三级缓存 6144KB。

在执行书中示例代码的过程中，发现有些结果与书中结论误差较大，甚至有些结果显得不可思议。以下通过几个实验具体分析：

## 1、书中第五章程序优化示例的复现

`程序优化.cpp`对书中 P347 - P349 的代码执行若干次优化，将结果输出到 result.txt 文件中，并利用`calCPE.m`拟合 CPE，由于时间关系，仅分析了整数乘法，得到结果如下（括号中为书中结果）：

![image](https://user-images.githubusercontent.com/56211928/144714756-1d40a9db-2e64-46bb-bb44-69c1b9d01f00.png)

存在以下几个问题

- 对于 combine3，书中的结论是由于函数调用内部的分支可以被高度预测，故这个优化没有太大的效果。但在本地执行却发现这个优化的效果很显著，可能由于本地计算机 CPU 的分支预测做的不太好。
- 对于 combine4，该代码性能在书中得到了很好的提升，但本地执行时发现程序性能并没有提升，可能因为本地计算机 CPU 对内存读写的性能较好，在数据量较小的情况下不会产生额外的数据开销。
- 对于 combine5，书中的结论是由于 combine4 的程序已经达到了延迟界限，故 combine5 的优化没有效果。但这个优化却在本地计算机上有不错的效果，可能还是因为本地计算机 CPU 的分支预测问题，使得循环开销仍然是影响程序性能的关键因素之一。

整个实验，由于对本地计算机 CPU 的具体数据不清楚，难以估计每个操作的延迟界限和吞吐量界限。但值得欣慰的是，一系列的优化过程虽然和书中结论有些不符，但还是能够看到优化对程序性能确实起到不错的改进效果。

## 2、书中第六章存储器山的复现

`存储器山.cpp`对书中 P444 的代码进行复现，得到的结果和书中结论差异甚大，请看如下分析：


