# 第五章

## 1、定义 CPE

引入度量标准每元素的周期数——CPE，作为一种表示程序性能并指导代码改进的方法。CPE 需要通过对某段程序使用不同的元素数量重复执行，再利用最小二乘法进行估计。一个估算 CPE 的示例图如下：

![image](https://user-images.githubusercontent.com/56211928/144694730-ba6664c1-ddd4-49df-8021-44537c008579.png)

通过最小二乘法拟合，得到 psum1 = 368 + 9.0n，psum2 = 368 + 6.0n，故知 psum1 和 psum2 的 CPE 分别是 9.0 和 6.0。

## 2、理解现代处理器

在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。现代处理器采用超标量技术，即利用多个执行相同操作的功能部件，在每个时钟周期执行多个操作。流水线采用乱序方式，指令的执行顺序不一定于机器程序中的顺序一致。

### 2.1 功能单元的性能

以 Intel Core i7 Haswell 为例，它执行某些算术运算所需的时钟周期如下：

![image](https://user-images.githubusercontent.com/56211928/144695023-1dc61a53-a1e9-407a-8a61-90c9126d1afd.png)

对于每个操作，由以下三种变量来刻画：

- 延迟 (latency), 它表示完成运算所需要的总时间
- 发射时间 (issue time), 它表示两个连续的同类型的运算之间需要的最小时钟周期数
- 容量 (capacity), 它表示能够执行该运算的功能单元的数量

发射时间为 1 的功能单元被称为是完全流水化的，每个周期可以开始一个新的运算。在没有数据冲突的情况下，完全流水化的指令可以认为在 1 个周期内即可执行完毕。

对于一个容量为 C，发射时间为 I 的操作来说，处理器可能获得的最大吞吐量为每个时钟周期 C / I 个操作。

### 2.2 程序性能上限

- **延迟界限**给出了任何必须严格按照顺序完成运算的函数所需要的最小 CPE 值，等于该操作的延迟数。
- **吞吐量界限**给出了理论上 CPE 的最小值，等于容量除以发射时间。

对于整数和浮点数的一些操作，Intel Core i7 Haswell 的性能如下：

![image](https://user-images.githubusercontent.com/56211928/144695409-6f056f5b-182d-46d0-95c7-e61997b1c980.png)

## 3、程序优化示例

### 3.1 基本优化

以下代码对数组 v 执行一系列操作，将结果存储在 dest 中，其中 IDENT 为 0 或 1，分别对应 OP 为 + 或 * ：

![image](https://user-images.githubusercontent.com/56211928/144695491-86c69756-4d05-4fbe-928a-8823767178dc.png)

以上代码的效率并不高，以下对其执行一系列代码变化：

- 消除循环的低效率：将循环内部的 i < vec_length(v) 外提。
- 减少过程调用：利用 get_vec_start 获取数组首地址，无需使用循环内部的 get_vec_element 来获取数组元素。
- 消除不必要的内存引用：创建一个新的临时变量 acc，迭代时对 acc 进行更新，最后将 acc 赋给 \*dest

现在得到如下代码：

![image](https://user-images.githubusercontent.com/56211928/144696067-1bfd0863-2620-4a14-90b9-f1d842247e6f.png)

各个版本代码的效果如下：

![image](https://user-images.githubusercontent.com/56211928/144709427-b5916278-ae63-42ee-a4ef-55dacc2e7539.png)
![image](https://user-images.githubusercontent.com/56211928/144709438-14f2608c-18c3-455e-9efd-c1d607ee7d4b.png)
![image](https://user-images.githubusercontent.com/56211928/144709444-f97b33fc-da93-43ab-bf5f-c8e591db899e.png)

combine4 的结果已经接近延迟界限，接下来，试图利用 cpu 内部特性进行优化。

### 3.2 处理器操作的抽象模型

程序的数据表示是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的关键路径, 这是执行一组机器指令所需时钟周期数的一个下界。

对于形成循环的代码片段，可以将访问到的寄存器分为 4 类：

- 只读：寄存器只用作源值，在循环中不会被修改。
- 只写：寄存器只作为数据传送的目的。
- 局部：寄存器在循环内部被修改和使用，但迭代与迭代之间不相关。
- 循环：寄存器既作为源值，有作为目的，并且一次迭代中产生的值会在另一次迭代中用到。

**循环寄存器之间的操作链决定了限制性能的数据相关**

观察以下代码：

![image](https://user-images.githubusercontent.com/56211928/144709796-093ee226-1895-4daf-b8a0-e45684ccd2f1.png)

其中，rax 是只读存储器，条件码寄存器是局部寄存器，rdx 和 xmm0 是循环寄存器。如果只观察循环寄存器值的变化，可做出如下示意图：

![image](https://user-images.githubusercontent.com/56211928/144709902-6a2e26e3-dd91-4af5-8841-978237398e6f.png)

由此形成的关键路径如下：

![image](https://user-images.githubusercontent.com/56211928/144709929-f7ee32fe-8b49-4e96-9d1e-dca8711e31e1.png)

程序有两条数据相关链，分别对应于 mul 和 add 对程序值 acc 和 data + i 的修改。假设浮点乘法延迟为 5 个周期，而整数加法延迟为 1 个周期，则左边的链会形成关键路径，需要 5n 个周期执行。

### 3.3 利用 cpu 的性能进一步优化程序

- 循环展开：通过增加每次迭代计算的元素的数量，减少循环的迭代次数。2 * 1 的循环展开如下：

![image](https://user-images.githubusercontent.com/56211928/144710418-6cc60683-34e9-476d-953f-6b76f29d82d0.png)

只观察循环寄存器值的变化，可做出如下示意图：

![image](https://user-images.githubusercontent.com/56211928/144710776-1c706e81-f754-4e3c-bfc0-732bb7588324.png)

由此形成的关键路径如下：

![image](https://user-images.githubusercontent.com/56211928/144710785-6618807d-4fb3-457b-8475-3908eb2f00a8.png)

本例中，这种方法效果不佳，因为程序已经达到了延迟界限，展开后的程序中，每次迭代仍然需要对变量 acc 进行两次更新，对于乘法操作而言，其关键路径上仍然是 n 个 mul 操作。

- 提高并行性：在 2 * 1 循环展开的基础上，建立多个中间变量，提高并行性。2 * 2 的循环展开如下：

![image](https://user-images.githubusercontent.com/56211928/144710747-dfdac28c-0b79-4d2e-ad56-921653dc3bb9.png)

只观察循环寄存器值的变化，可做出如下示意图：

![image](https://user-images.githubusercontent.com/56211928/144713659-d0805a40-458f-4a15-b5a1-b4bd3146885a.png)

由此形成的关键路径如下：

![image](https://user-images.githubusercontent.com/56211928/144713646-c65390da-63a4-4d5a-99fd-e929b7374ef6.png)

这种情况的 CPE 得到近 2 倍的提升。这是因为在前面 2 * 1 的循环展开中，我们将累计值放在 1 个 acc 中，虽然功能部件每个时钟周期开始一个新的操作，但是它只会每 L 个周期开始一条新操作。定义两个累计变量可以打破这种限制。**通常，只有保持能够执行该操作的所有功能单元的流水线都是满的，程序才能达到这个操作的吞吐量界限**。

- 重新结合变换

仍然考虑 2 * 1 的循环展开，对于 acc 变量的更新可以有如下两种方式：

    acc = (acc OP data[i]) OP data[i + 1]
    或
    acc = acc OP (data[i] OP data[i + 1])

现在使用第二种更新方式，这种方式称为 2 * 1a 展开，同样只观察循环寄存器值的变化，可做出如下示意图：

![image](https://user-images.githubusercontent.com/56211928/144711438-dd2afaff-4016-45b5-bcee-b81a899cabd5.png)

由此形成的关键路径如下：

![image](https://user-images.githubusercontent.com/56211928/144711449-2144f685-ca58-4af1-9bb8-d679d558512f.png)

虽然每次循环内部的两次 mul 操作存在数据相关，但是**在乱序流水线中，循环内的第一个乘法不需要等待前一次迭代的累计值就可以执行**。该方法得到的性能与 2 * 2 展开类似。

### 3.4 程序优化小结

经过一系列的优化，各个操作的 CPE 已经接近吞吐量界限，如下图：

![image](https://user-images.githubusercontent.com/56211928/144712296-71ccf0ed-59bc-49cc-b478-cd7d46fa47a9.png)

在一个程序的数据流图表示中，关键路径指明了执行该程序所需时间的一个基本的下界。也就是说，如果程序中有某条数据相关链，这条链上的所有延迟之和等于 T, 那么这个程序至少需要 T 个周期才能执行完。我们还看到功能单元的吞吐量界限也是程序执行时间的一个下界。也就是说，假设一个程序一共需要 N 个某种运算的计算，而微处理器只有 C 个能执行这个操作的功能单元，并且这些单元的发射时间为 I。那么，这个程序的执行至少需要 N * I / C 个周期。

## 4、优化程序性能的基本策略

**高级设计——选择适当的算法和数据结构**

**基本编码原则——避免限制优化的因素**
- 消除连续的函数调用，在可能时，将计算移动到循环外。
- 消除不必要的内存引用，因入临时变量来保存中间结果，只有在最后的计算出来时，才将结果存放到数组或全局变量中。
- 用功能性的风格重写条件操作，使得编译采用条件传送。

**低级优化**
- 循环展开，减少循环的开销。
- 通过使用多个累计变量和重新结合等技术，找到方法提高指令级并行。

对于条件分支的结果在本质上就无法预测时，如果能让编译器产生使用条件数据传送而不是条件控制转移的代码，可以极大地提高程序的性能。以下展示一个原始代码和条件传送代码的对比：

![image](https://user-images.githubusercontent.com/56211928/144731737-e2f797fd-4d94-41a1-bb59-f2e074bf55fb.png)

右侧条件传送的代码对**两种可能结果都进行求值**，再根据判断条件给结果赋值。


