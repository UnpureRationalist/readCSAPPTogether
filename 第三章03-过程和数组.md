# 第三章03-过程和数组

## 1、过程

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程调用过程的例子中，可以看到当在执行时，以及所有在向上追溯到的调用链中的过程，都是暂时被挂起的。当运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当返回时，任何它所分配的局部存大储空间都可以被释放。以下是函数 P 调用 函数 Q 时，栈的示意图：

![image](https://user-images.githubusercontent.com/56211928/142960509-401922ca-d9d0-4a76-90ec-af2591200bbc.png)

当 x86-64 被调函数需要的存储空间超出寄存器能够存放的大小时，主调函数就会在栈上分配空间。这个部分称为过程的栈帧。x86-64 允许主调函数利用寄存器传递最多 6 个整数值（也就是指针和整数）。当前正在执行的过程的帧总是在栈顶。当过程 P 调用过程 Q 时，把返回地址压入栈中，指明当 Q 返回时，要从程序的哪个位置继续执行，我们把这个返回地址当做 P 的栈帧的一部分。

将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器（PC）设置为 Q 的代码的起始位置，并记录好返回时的位置。这个过程可以利用 call 指令完成。call Q 用来调用函数 Q，并将该指令下一条指令的地址压入栈，在过程 Q 中，ret 指令从栈中弹出返回地址，并设置 PC。call 和 ret 指令的格式如下：

![image](https://user-images.githubusercontent.com/56211928/142961561-d071f0ed-aa15-430a-92fd-c013c622a658.png)

---
除了函数调用外，一般还有 3 中情况需要使用栈

- 函数传参时，寄存器不足够存放本地数据。
- 对一个局部变量使用了 & 符号，因此必须在栈中为其分配一个内存地址。
- 根据寄存器的使用规则，保护一些寄存器中的内容。
- 某些局部变量是数组或结构，必须能够通过数组或结构引用被访问到。

以下分别介绍前三种情况所使用的栈，对于数组和结构的情况，后面再详细介绍。

### 函数调用时的栈

上面已经提到，函数调用时，最多只可以通过寄存器传递 6 个整数（整数和指针），如果一个函数有大于 6 个整形参数，超出 6 个的部分就要通过栈来传递，即主调函数的代码需要在自己对应的栈中分配 7 - n 号参数的存储空间。以下是一个利用栈传参的示例：

![image](https://user-images.githubusercontent.com/56211928/142962011-02822c89-83a5-4a58-9f91-ca3c65775fb0.png)

可以看到，在被调函数中，6 个参数通过寄存器传递，2 个参数通过栈传递。通过栈传递参数时，要求所有的参数地址向 8 对其。作为调用过程的一部分，返回地址也被压入栈中，并位于栈顶。因此通过栈传递的两个参数分别位于距栈顶 8 和 16 的位置，栈的示意图如下：

![image](https://user-images.githubusercontent.com/56211928/142962640-500bb307-31a0-454e-8176-146aff4bcdb4.png)


### & 符号所涉及的栈

当局部变量使用 & 符号时，需要在栈上分配空间来存储该变量。以下是一个具体示例：

![image](https://user-images.githubusercontent.com/56211928/142963280-6b66af1f-efb0-45ff-b2d5-1611ca16ae5e.png)
![image](https://user-images.githubusercontent.com/56211928/142963332-50d03948-c526-4a2a-86d6-ce94e5a3994d.png)

以下对汇编代码做具体分析：

- 利用栈传参，数据必须向 8 对齐。
- 利用栈指明 & 变量的地址，无需向 8 对其。
- 3、4、5、6 行代码，为 & 变量分配空间。
- 8、10、12、14 行代码，传递 & 变量的地址。
- 9、11、13、15 行代码，传递普通参数值。
- 17、18、19、20 行代码，重新获取 & 变量的值，并进行相关计算。

栈示意图如下：

![image](https://user-images.githubusercontent.com/56211928/142963617-604bc20d-90c6-4f4d-9c15-3d60fe076f5b.png)

注意，这个图代表的是函数调用前，或调用返回后的情况。当被调函数执行时，主调函数的返回地址也应该压入栈。

### 利用栈维护寄存器值

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

根据惯例，寄存器 %rbx %rbp %r12~%r15 被划分为被调用者保存寄存器。当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在返回到时与被调用时是一样的。过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。有了这条惯例，P 的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用 Q，然后继续使用寄存器中的值，不用担心值被破坏。

所有其他的寄存器，除了栈指针 %rsp, 都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程 P 在某个此类寄存器中有局部数据，然后调用过程 Q。因为 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P (调用者）的责任。

来看一个例子：

![image](https://user-images.githubusercontent.com/56211928/142965824-4af4c72f-fcbd-4d10-8bca-5fda8499561c.png)

该例中，函数 P 两次调用函数 Q，在第一次调用时，P 将 x 存放在 %rbp 中（第 5 行），表明 x 需要被 Q 保护。第二次调用时，将 x 从 %rbp 中取出（第 9 行），并作为参数传递给 Q。

---
## 2、数组

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。

对于数据类型 和整型常数 N, 声明如下：

      T A[N]
        
设数组起始位置为 x，这个声明有两个效果。首先，在内存中分配一个 L * N 字节的连续区域。这里 L 是数据类型 T 的大小。其次，因入标识符 A，可以用 A 来作为指向数组开头的指针，该指针的值就是 x。

假设 E 是一个 int 型的数组，而我们想计算 E[i]，在此，E 的地址存放在寄存器 %rdx 中，而 i 存放在寄存器 %rcx 中。然后，指令 

      movl (%rdx, %rcx, 4), %eax
      
会执行地址计算 E + 4i，读这个内存位置的值，并将结果存放到寄存器 %eax 中。更一般的，以下是一些对数组 E 进行相关计算的表达式和其对应的汇编代码：

![image](https://user-images.githubusercontent.com/56211928/142967238-cb19dbe7-0d02-4706-91cd-59409a4eab32.png)

注意到，计算同一个数据结构中的两个指针之差，结果的数据类型为 long，值等于两个地址之差除以该数据类型的大小。

### 嵌套数组

当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。声明：

      int A[5][3]
      
等价于声明：

      typedef int row3_t[3]
      row3_t A[5]
      
数据类型 row3_t 被定义为一个 3 个整数的数组。数组 A 包含 5 个这样的元素。数组元素在内存中按照“行优先”的顺序排列。第 0 行的所有元素（A[0])后面跟着第 1 行的所有元素。

要访问多维数组的元素，编译器会以数组起始为基地址，（可能需要经过伸缩的）偏移量为索引，产生计算期望的元素的偏移量，然后使用某种 MOV 指令。通常来说，对于一个声明如下的数组：

      T D[R][C]
      
它的数组元素 D[i][j] 的内存地址为：

      &D[i][j] = x0 + L(C * i + j)
      
其中，L 是数据类型 T 以字节为单位的大小。

如下的示例将 5 * 3 的整形数组 A 中，A [i][j] 的值复制到 %eax 中（设 A、i、j 分别在寄存器 %rdi，%rsi，$rdx 中）。

![image](https://user-images.githubusercontent.com/56211928/142973160-0a385850-4602-4ffa-9fdf-2c821f0efba5.png)

### 变长数组

历史上，C 语言只支持大小在编译时就能确定的数组数组。ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。在变长数组的 C 版本中，我们可以将一个数组声明如下：

      int A[expr1][expr2]
      
它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式 expr1 和 expr2 求值来确定数组的维度。例如，想要访问 n * n 数组的元素 i，j，我们可以写一个如下的函数：

![image](https://user-images.githubusercontent.com/56211928/142974454-cbf8596f-ea32-4862-a2ae-91021a7b2d68.png)

参数 n 必须在参数 A[n][n] 之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。相应的汇编代码如下：

![image](https://user-images.githubusercontent.com/56211928/142974969-f98c434e-051c-45ad-8126-c8fdaa53683f.png)

这段代码计算元素 i，j 的地址为

      A + 4(n * i) + 4j = A + 4(n * i + j)
      
这个地址的计算类似于定长数组的计算，而动态的版本需要用乘法指令对 i 伸缩 n 倍。

