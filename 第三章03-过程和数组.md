# 第三章03-过程和数组

## 1、过程

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程调用过程的例子中，可以看到当在执行时，以及所有在向上追溯到的调用链中的过程，都是暂时被挂起的。当运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当返回时，任何它所分配的局部存大储空间都可以被释放。以下是函数 P 调用 函数 Q 时，栈的示意图：

![image](https://user-images.githubusercontent.com/56211928/142960509-401922ca-d9d0-4a76-90ec-af2591200bbc.png)

当 x86-64 被调函数需要的存储空间超出寄存器能够存放的大小时，主调函数就会在栈上分配空间。这个部分称为过程的栈帧。x86-64 允许主调函数利用寄存器传递最多 6 个整数值（也就是指针和整数）。当前正在执行的过程的帧总是在栈顶。当过程 P 调用过程 Q 时，把返回地址压入栈中，指明当 Q 返回时，要从程序的哪个位置继续执行，我们把这个返回地址当做 P 的栈帧的一部分。

将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器（PC）设置为 Q 的代码的起始位置，并记录好返回时的位置。这个过程可以利用 call 指令完成。call Q 用来调用函数 Q，并将该指令下一条指令的地址压入栈，在过程 Q 中，ret 指令从栈中弹出返回地址，并设置 PC。call 和 ret 指令的格式如下：

![image](https://user-images.githubusercontent.com/56211928/142961561-d071f0ed-aa15-430a-92fd-c013c622a658.png)

---
除了函数调用外，一般还有 4 种情况需要使用栈

- 函数传参时，寄存器不足够存放本地数据。
- 对一个局部变量使用了 & 符号，因此必须在栈中为其分配一个内存地址。
- 根据寄存器的使用规则，保护一些寄存器中的内容。
- 某些局部变量是数组或结构，必须能够通过数组或结构引用被访问到。

以下分别介绍前三种情况所使用的栈，对于数组和结构的情况，后面再详细介绍。

### 函数调用时利用栈传参

上面已经提到，函数调用时，最多只可以通过寄存器传递 6 个整数（整数和指针），如果一个函数有大于 6 个整形参数，超出 6 个的部分就要通过栈来传递，即主调函数的代码需要在自己对应的栈中分配 7 - n 号参数的存储空间。以下是一个利用栈传参的示例：

![image](https://user-images.githubusercontent.com/56211928/142962011-02822c89-83a5-4a58-9f91-ca3c65775fb0.png)

可以看到，在被调函数中，6 个参数通过寄存器传递，2 个参数通过栈传递。通过栈传递参数时，要求所有的参数地址向 8 对其。作为调用过程的一部分，返回地址也被压入栈中，并位于栈顶。因此通过栈传递的两个参数分别位于距栈顶 8 和 16 的位置，栈的示意图如下：

![image](https://user-images.githubusercontent.com/56211928/142962640-500bb307-31a0-454e-8176-146aff4bcdb4.png)


### & 符号所涉及的栈

当局部变量使用 & 符号时，需要在栈上分配空间来存储该变量。以下是一个具体示例：

![image](https://user-images.githubusercontent.com/56211928/142963280-6b66af1f-efb0-45ff-b2d5-1611ca16ae5e.png)
![image](https://user-images.githubusercontent.com/56211928/142963332-50d03948-c526-4a2a-86d6-ce94e5a3994d.png)

以下对汇编代码做具体分析：

- 利用栈传参，数据必须向 8 对齐。
- 利用栈指明 & 变量的地址，无需向 8 对其。
- 3、4、5、6 行代码，为 & 变量分配空间。
- 8、10、12、14 行代码，传递 & 变量的地址。
- 9、11、13、15 行代码，传递普通参数值。
- 17、18、19、20 行代码，重新获取 & 变量的值，并进行相关计算。

栈示意图如下：

![image](https://user-images.githubusercontent.com/56211928/142963617-604bc20d-90c6-4f4d-9c15-3d60fe076f5b.png)

注意，这个图代表的是函数调用前，或调用返回后的情况。当被调函数执行时，主调函数的返回地址也应该压入栈。

### 利用栈维护寄存器值

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

根据惯例，寄存器 %rbx %rbp %r12~%r15 被划分为被调用者保存寄存器。当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在返回到时与被调用时是一样的。过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。有了这条惯例，P 的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用 Q，然后继续使用寄存器中的值，不用担心值被破坏。

所有其他的寄存器，除了栈指针 %rsp, 都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程 P 在某个此类寄存器中有局部数据，然后调用过程 Q。因为 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P (调用者）的责任。

来看一个例子：

![image](https://user-images.githubusercontent.com/56211928/142965824-4af4c72f-fcbd-4d10-8bca-5fda8499561c.png)

该例中，函数 P 两次调用函数 Q，在第一次调用时，P 将 x 存放在 %rbp 中（第 5 行），表明 x 需要被 Q 保护。第二次调用时，将 x 从 %rbp 中取出（第 9 行），并作为参数传递给 Q。

---
## 2、数组

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。

对于数据类型 和整型常数 N, 声明如下：

      T A[N]
        
设数组起始位置为 x，这个声明有两个效果。首先，在内存中分配一个 L * N 字节的连续区域。这里 L 是数据类型 T 的大小。其次，因入标识符 A，可以用 A 来作为指向数组开头的指针，该指针的值就是 x。

假设 E 是一个 int 型的数组，而我们想计算 E[i]，在此，E 的地址存放在寄存器 %rdx 中，而 i 存放在寄存器 %rcx 中。然后，指令 

      movl (%rdx, %rcx, 4), %eax
      
会执行地址计算 E + 4i，读这个内存位置的值，并将结果存放到寄存器 %eax 中。更一般的，以下是一些对数组 E 进行相关计算的表达式和其对应的汇编代码：

![image](https://user-images.githubusercontent.com/56211928/142967238-cb19dbe7-0d02-4706-91cd-59409a4eab32.png)

注意到，计算同一个数据结构中的两个指针之差，结果的数据类型为 long，值等于两个地址之差除以该数据类型的大小。

### 嵌套数组

当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。声明：

      int A[5][3]
      
等价于声明：

      typedef int row3_t[3]
      row3_t A[5]
      
数据类型 row3_t 被定义为一个 3 个整数的数组。数组 A 包含 5 个这样的元素。数组元素在内存中按照“行优先”的顺序排列。第 0 行的所有元素（A[0]）后面跟着第 1 行的所有元素。

要访问多维数组的元素，编译器会以数组起始为基地址，（可能需要经过伸缩的）偏移量为索引，产生计算期望的元素的偏移量，然后使用某种 MOV 指令。通常来说，对于一个声明如下的数组：

      T D[R][C]
      
它的数组元素 D[i][j] 的内存地址为：

      &D[i][j] = x0 + L(C * i + j)
      
其中，L 是数据类型 T 以字节为单位的大小。

如下的示例将 5 * 3 的整形数组 A 中，A [i][j] 的值复制到 %eax 中（设 A、i、j 分别在寄存器 %rdi，%rsi，$rdx 中）。

![image](https://user-images.githubusercontent.com/56211928/142973160-0a385850-4602-4ffa-9fdf-2c821f0efba5.png)

### 变长数组

历史上，C 语言只支持大小在编译时就能确定的数组数组。ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。在变长数组的 C 版本中，我们可以将一个数组声明如下：

      int A[expr1][expr2]
      
它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式 expr1 和 expr2 求值来确定数组的维度。例如，想要访问 n * n 数组的元素 i，j，我们可以写一个如下的函数：

![image](https://user-images.githubusercontent.com/56211928/142974454-cbf8596f-ea32-4862-a2ae-91021a7b2d68.png)

参数 n 必须在参数 A[n][n] 之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。相应的汇编代码如下：

![image](https://user-images.githubusercontent.com/56211928/142974969-f98c434e-051c-45ad-8126-c8fdaa53683f.png)

这段代码计算元素 i，j 的地址为

      A + 4(n * i) + 4j = A + 4(n * i + j)
      
这个地址的计算类似于定长数组的计算，而动态的版本需要用乘法指令对 i 伸缩 n 倍。

---
## 3、异质数据结构

C 语言提供了两种将不同类型的对象组合到一起来创建数据类型的机制：结构（struct）和联合（union）。

### 结构

类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段（如Id) 的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

考虑下面这样的结构声明：

![image](https://user-images.githubusercontent.com/56211928/142990096-70fc573c-b5c4-48a2-ae39-e12cebd58938.png)

该结构包含 4 个字段，对应内存中的内容如下：

![image](https://user-images.githubusercontent.com/56211928/142990557-ec224b23-c2f4-4c4a-a145-9d319c6b6b9f.png)

为了访问结构的字段，需要产生一个指向结构内部对象的指针，即编译器需要将结构的地址加上适当的偏移。例如：

      r->p = &r->a[r->i + r->j]
      
对应的汇编代码如下：

![image](https://user-images.githubusercontent.com/56211928/142990966-fdae9be5-547c-4489-9701-7d74036ab257.png)

### 联合

联合提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样。一个联合总的大小等于它最大字段的大小。联合提出的目的是为了节约内存空间，但通常来讲，现有计算机的存储空间普遍较大，利用联合对代码造成的麻烦往往比于节省的空间更大。不过，联合还可以用来访问不同数据的位模式。请参考`联合.cpp`

