# 第三章03-过程和数组

## 1、过程

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程调用过程的例子中，可以看到当在执行时，以及所有在向上追溯到的调用链中的过程，都是暂时被挂起的。当运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当返回时，任何它所分配的局部存大储空间都可以被释放。以下是函数 P 调用 函数 Q 时，栈的示意图：

![image](https://user-images.githubusercontent.com/56211928/142960509-401922ca-d9d0-4a76-90ec-af2591200bbc.png)

当 x86-64 被调函数需要的存储空间超出寄存器能够存放的大小时，主调函数就会在栈上分配空间。这个部分称为过程的栈帧。x86-64 允许主调函数利用寄存器传递最多 6 个整数值（也就是指针和整数）。当前正在执行的过程的帧总是在栈顶。当过程 P 调用过程 Q 时，把返回地址压入栈中，指明当 Q 返回时，要从程序的哪个位置继续执行，我们把这个返回地址当做 P 的栈帧的一部分。

将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器（PC）设置为 Q 的代码的起始位置，并记录好返回时的位置。这个过程可以利用 call 指令完成。call Q 用来调用函数 Q，并将该指令下一条指令的地址压入栈，在过程 Q 中，ret 指令从栈中弹出返回地址，并设置 PC。call 和 ret 指令的格式如下：

![image](https://user-images.githubusercontent.com/56211928/142961561-d071f0ed-aa15-430a-92fd-c013c622a658.png)

---
除了函数调用外，一般还有 3 中情况需要使用栈

- 函数传参时，寄存器不足够存放本地数据。
- 对一个局部变量使用了 & 符号，因此必须在栈中为其分配一个内存地址。
- 某些局部变量是数组或结构，必须能够通过数组或结构引用被访问到。

以下分别介绍前两种情况所使用的栈，对于数组和结构的情况，后面再详细介绍。

**函数调用时的栈**

上面已经提到，函数调用时，最多只可以通过寄存器传递 6 个整数（整数和指针），如果一个函数有大于 6 个整形参数，超出 6 个的部分就要通过栈来传递，即主调函数的代码需要在自己对应的栈中分配 7 - n 号参数的存储空间。以下是一个利用栈传参的示例：

![image](https://user-images.githubusercontent.com/56211928/142962011-02822c89-83a5-4a58-9f91-ca3c65775fb0.png)

可以看到，在被调函数中，6 个参数通过寄存器传递，2 个参数通过栈传递。通过栈传递参数时，要求所有的参数地址向 8 对其。作为调用过程的一部分，返回地址也被压入栈中，并位于栈顶。因此通过栈传递的两个参数分别位于距栈顶 8 和 16 的位置，栈的示意图如下：

![image](https://user-images.githubusercontent.com/56211928/142962640-500bb307-31a0-454e-8176-146aff4bcdb4.png)

**& 符号所涉及的栈*

当局部变量使用 & 符号时，需要在栈上分配空间来存储该变量。以下是一个具体示例：

![image](https://user-images.githubusercontent.com/56211928/142963280-6b66af1f-efb0-45ff-b2d5-1611ca16ae5e.png)
![image](https://user-images.githubusercontent.com/56211928/142963332-50d03948-c526-4a2a-86d6-ce94e5a3994d.png)

以下对汇编代码做具体分析：

- 利用栈传参，数据必须向 8 对齐。
- 利用栈指明 & 变量的地址，无需向 8 对其。
- 3、4、5、6 行代码，为 & 变量分配空间。
- 8、10、12、14 行代码，传递 & 变量的地址。
- 9、11、13、15 行代码，传递普通参数值。
- 17、18、19、20 行代码，重新获取 & 变量的值，并进行相关计算。

栈示意图如下：

![image](https://user-images.githubusercontent.com/56211928/142963617-604bc20d-90c6-4f4d-9c15-3d60fe076f5b.png)

注意，这个图代表的是函数调用前，或调用返回后的情况。当被调函数执行时，主调函数的返回地址也应该压入栈。


