# 第八章

## 1、异常

异常是控制流中的突变，由软件和硬件共同实现。当处理器检测到有事件发生时，会通过一张叫做异常表的跳转表，进行一个间接的过程调用，到一个专门设计用来处理这类事件的操作系统子程序。

![image](https://user-images.githubusercontent.com/56211928/146646389-cc62cd4a-1795-4c55-884e-5cb83a718fcd.png)

当异常处理程序完成这个处理后，根据引起异常事件的类型，出现以下 3 种情况的一种：

- 处理程序将控制返回给当前指令，即当事件发生时执行的指令。
- 处理程序将控制返回给当前指令的下一条指令。
- 处理程序终止

异常处理类似于过程调用，但有以下几点不同：

- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在前指令后执行的指令）。
- 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如， x86-64 系统会将包含当前条件码的 EFLAGS寄存器和其他内容压入栈中。
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中 而不是压到用户栈中。
- 异常处理程序运行在内核模式下（见 2. 节），这意味 它们对所有的系统资源都有完全的访问权限。

---

### 异常的类别

异常可以分为终端、陷阱、故障和终止 4 类，如下图：

![image](https://user-images.githubusercontent.com/56211928/146646671-f6684a21-151f-43bb-909e-323416db82b4.png)

**中断**

中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。I/O 设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。除了中断之外的异常均是同步发生的。

![image](https://user-images.githubusercontent.com/56211928/146646799-e453bc82-ffe2-44f8-9464-e6d7083bc6a0.png)

**陷阱**

陷阱是有意的异常，是执行一条指令的结果。最典型的陷阱是系统调用。用户程序经常需要向内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 syscall n 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。

![image](https://user-images.githubusercontent.com/56211928/146646954-7858fc54-a37e-4c4e-af55-a83adc60bf67.png)

常见的系统调用如下图：

![image](https://user-images.githubusercontent.com/56211928/146647150-3fae186e-f01c-466b-9953-bbee13045fb8.png)

**故障**

故障由错误情况引起，它可能能够被故障处理程序修正。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程， abort 例程会终止引起故障的应用程序。一个经典的故障是缺页异常。

![image](https://user-images.githubusercontent.com/56211928/146647007-59d38f8b-d23b-4f7c-891d-b0edac1d8523.png)

**终止**

终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。

![image](https://user-images.githubusercontent.com/56211928/146647055-64518147-987d-4c48-b89d-3ae1572113ae.png)

## 2、进程

在现代系统上运行 个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。

进程是一个执行中程序的示例。每个程序都运行在某个进程的上下文中。**上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合**。

处理器通常是用某个控制寄存器中的一个模式位来标志用户和内核模式。当设置了模式位时，进程就运行在内核模式中。用户模式中的进程不允许执行特权指令, 比如停止处理器、改变模式位，或者发起一个 I/0 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。

### 进程控制

**获取进程 ID**

每个进程都有一个唯一的正数 ID，也叫做 PID，getpid 函数返回调用进程的 PID，getppid 函数返回它的父进程的 PID。

![image](https://user-images.githubusercontent.com/56211928/146647752-94dc3d34-ab69-41bc-b05f-9806c4437935.png)

返回类型 pid_t 在 Linux 系统上在 type.h 中被定义为 int。

**创建进程**

父进程使用 fork 函数创建一个子进程，fork 函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID 。在子进程中，fork 返回 0。返回值提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。

![image](https://user-images.githubusercontent.com/56211928/146647844-4ceee59b-f9a1-4f37-ae71-e5cfdb63fd03.png)

子进程和父进程有如下关系：

- **并发执行：父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令**。
- 相同但是独立的地址空间：两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变最值、相同的堆、相同的全局变鼠值，以及相同的代码。
- 共享文件：子进程继承了父进程所有的打开文件。

**终止进程**

exit 函数以 status 退出状态来终止进程。

![image](https://user-images.githubusercontent.com/56211928/146647955-e62a9d3d-4a37-4237-bf45-030c9dadc4cd.png)

**回收进程**

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收己终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃己终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程。一个进程可以调用 waitpid 函数来等待它的紫禁城终止或者停止，**并将其回收**。

![image](https://user-images.githubusercontent.com/56211928/146648097-f10cda75-d775-4851-b286-000e39e3b50f.png)

如果 pid > 0，等待集合是一个单独的子进程，如果 pid = -1，等待集合是父进程创建的所有子进程。

默认情况下（当 options = O，statusp = NULL 时），waitpid 挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个或多个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。在这两种情况中， waitpid 返回终止子进程的 PID（如果有多个终止子进程，任意返回其中一个）。

如果调用进程没有子进程，那么 waitpid 返回 —1, 并且设置 errno 为 ECHILD 。如 waitpid 函数被一个信号中断，那么它返回 —1, 并设置 errno 为 EINTR。其中，error 是一个全局整数变量，当系统级函数遇到错误时，该变量表明错误类型，strerror(errno) 是一个报告函数错误的字符串。 

**进程休眠**

sleep 函数将一个进程挂起一段指定的时间。

![image](https://user-images.githubusercontent.com/56211928/146648623-c09f539c-1c5c-476a-85be-b2b853da2126.png)

pause 函数也可以让进程休眠，直到该进程收到一个信号。

![image](https://user-images.githubusercontent.com/56211928/146648665-89010f72-ce25-4a1c-91dd-26b2055a070e.png)

**加载并运行程序**

execve 函数在当前进程上下文中加载并运行一个新程序

![image](https://user-images.githubusercontent.com/56211928/146648761-cc7ef131-37ec-4aff-b81b-d6408d8f2c17.png)

execve 函数加载并运行可执行目标文件 filename, 且带参数列表 argv 和环境变量列表 envp。新进程它会覆盖当前进程的地址空间（原进程的数据和代码丢失）, 并且继承了调用 execve 函数时已打开的所有文件，新的程序仍然有相同的 PID 描述符。execve 调用一次并从不返回。

## 3、信号

信号是一种更高层的软件形式的异常，它允许进程和内核中断其他程序。例如程序在前台运行时，用户输入 Crtl + C，内核会发送 SIGINT 信号终止该进程组的程序，一个进程可以通过向另一个进程发送 SIGKILL 信号强行终止它。另外，信号还提供了一种机制，当出现底层硬件异常时，通知用户发生了这种异常。例如出现除 0，非法指令，非法内存异常时，内核会发送相应的信号通知用户。

一个发出而没有被接收的信号叫待处理信号，一种类型至多有一个待处理信号。当一个进程接收到一个和待处理的某个信号类型相同的信号时，进程会将其丢弃。一个进程可以有选择的阻塞某种信号，当一种信号被阻塞时，进程接收到该类信号后不会立刻处理它，而是将它设置成待处理信号，直到阻塞解除。

### 发送信号

内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。有以下两种原因：

- 内核检测到一个系统事件，比如除零错误或子进程终止。
- 一个进程调用 kill 函数，显示地要求内核发送一个信号给目的进程。

### 信号接收

当内核把进程 p 从内核模式切换到用户模式时，会检查进程 p 未被阻塞的待处理信号的集合。如果集合非空，内核会选择集合中的某个信号 k，强制 p 接收信号 k。每种信号有于其关联的默认行为，如下图：

![image](https://user-images.githubusercontent.com/56211928/146660067-8c90ac2a-518c-4a5a-b8bb-0556010ac4d9.png)

signal 函数可以修改和信号相关联的默认行为（不可以修改 SIGSTOP 和 SIGKILL）

![image](https://user-images.githubusercontent.com/56211928/146660141-c327e588-7724-4dbf-b34e-7287116b7251.png)

signal 函数可以通过下列三种方式来改变和信号 signum 相关联的行为：
 
- 如果 handler SIG_IGN, 那么忽略类型为 signum 的信号。
- 如果 handler SIG_DFL, 那么类型为 signum 的信号行为恢复为默认行为
- 否则，handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为。

下图的示例中，将 SIGINT 信号的行为修改为输出一条消息后终止进程，当用户键入 Ctrl + C 时，会看到终端输出 Caught SIGINT。

![image](https://user-images.githubusercontent.com/56211928/146660249-a37644e0-cb16-4d8d-a724-15baee2597e7.png)

### 阻塞和解除阻塞信号




