# 第八章

## 1、异常

异常是控制流中的突变，由软件和硬件共同实现。当处理器检测到有事件发生时，会通过一张叫做异常表的跳转表，进行一个间接的过程调用，到一个专门设计用来处理这类事件的操作系统子程序。

![image](https://user-images.githubusercontent.com/56211928/146646389-cc62cd4a-1795-4c55-884e-5cb83a718fcd.png)

当异常处理程序完成这个处理后，根据引起异常事件的类型，出现以下 3 种情况的一种：

- 处理程序将控制返回给当前指令，即当事件发生时执行的指令。
- 处理程序将控制返回给当前指令的下一条指令。
- 处理程序终止。

异常处理类似于过程调用，但有以下几点不同：

- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在前指令后执行的指令）。
- 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如， x86-64 系统会将包含当前条件码的 EFLAGS 寄存器和其他内容压入栈中。
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中而不是压到用户栈中。
- 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。

---

### 异常的类别

异常可以分为终端、陷阱、故障和终止 4 类，如下图：

![image](https://user-images.githubusercontent.com/56211928/146646671-f6684a21-151f-43bb-909e-323416db82b4.png)

**中断**

中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。I/O 设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。除了中断之外的异常均是同步发生的。

![image](https://user-images.githubusercontent.com/56211928/146646799-e453bc82-ffe2-44f8-9464-e6d7083bc6a0.png)

**陷阱**

陷阱是有意的异常，是执行一条指令的结果。最典型的陷阱是系统调用。用户程序经常需要向内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 syscall n 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。

![image](https://user-images.githubusercontent.com/56211928/146646954-7858fc54-a37e-4c4e-af55-a83adc60bf67.png)

常见的系统调用如下图：

![image](https://user-images.githubusercontent.com/56211928/146647150-3fae186e-f01c-466b-9953-bbee13045fb8.png)

**故障**

故障由错误情况引起，它可能能够被故障处理程序修正。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程， abort 例程会终止引起故障的应用程序。一个经典的故障是缺页异常。

![image](https://user-images.githubusercontent.com/56211928/146647007-59d38f8b-d23b-4f7c-891d-b0edac1d8523.png)

**终止**

终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。

![image](https://user-images.githubusercontent.com/56211928/146647055-64518147-987d-4c48-b89d-3ae1572113ae.png)

---

## 2、进程

在现代系统上运行 个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。

进程是一个执行中程序的示例。每个程序都运行在某个进程的上下文中。**上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合**。

处理器通常是用某个控制寄存器中的一个模式位来标志用户和内核模式。当设置了模式位时，进程就运行在内核模式中。用户模式中的进程不允许执行特权指令, 比如停止处理器、改变模式位，或者发起一个 I/0 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。

### 进程控制

**获取进程 ID**

每个进程都有一个唯一的正数 ID，也叫做 PID，getpid 函数返回调用进程的 PID，getppid 函数返回它的父进程的 PID。

![image](https://user-images.githubusercontent.com/56211928/146647752-94dc3d34-ab69-41bc-b05f-9806c4437935.png)

返回类型 pid_t 在 Linux 系统上在 type.h 中被定义为 int。

**创建进程**

父进程使用 fork 函数创建一个子进程，fork 函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID 。在子进程中，fork 返回 0。返回值提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。

![image](https://user-images.githubusercontent.com/56211928/146647844-4ceee59b-f9a1-4f37-ae71-e5cfdb63fd03.png)

子进程和父进程有如下关系：

- **并发执行：父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令**。
- 相同但是独立的地址空间：两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变最值、相同的堆、相同的全局变鼠值，以及相同的代码。
- 共享文件：子进程继承了父进程所有的打开文件。

**终止进程**

exit 函数以 status 退出状态来终止进程。

![image](https://user-images.githubusercontent.com/56211928/146647955-e62a9d3d-4a37-4237-bf45-030c9dadc4cd.png)

**回收进程**

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收己终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃己终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程。一个进程可以调用 waitpid 函数来等待它的紫禁城终止或者停止，**并将其回收**。

![image](https://user-images.githubusercontent.com/56211928/146648097-f10cda75-d775-4851-b286-000e39e3b50f.png)

如果 pid > 0，等待集合是一个单独的子进程，如果 pid = -1，等待集合是父进程创建的所有子进程。

默认情况下（当 options = O，statusp = NULL 时），waitpid 挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个或多个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。在这两种情况中， waitpid 返回终止子进程的 PID（如果有多个终止子进程，任意返回其中一个）。

如果调用进程没有子进程，那么 waitpid 返回 —1, 并且设置 errno 为 ECHILD 。如 waitpid 函数被一个信号中断，那么它返回 —1, 并设置 errno 为 EINTR。其中，error 是一个全局整数变量，当系统级函数遇到错误时，该变量表明错误类型，strerror(errno) 是一个报告函数错误的字符串。 

**进程休眠**

sleep 函数将一个进程挂起一段指定的时间。

![image](https://user-images.githubusercontent.com/56211928/146648623-c09f539c-1c5c-476a-85be-b2b853da2126.png)

pause 函数也可以让进程休眠，直到该进程收到一个信号。

![image](https://user-images.githubusercontent.com/56211928/146648665-89010f72-ce25-4a1c-91dd-26b2055a070e.png)

**加载并运行程序**

execve 函数在当前进程上下文中加载并运行一个新程序

![image](https://user-images.githubusercontent.com/56211928/146648761-cc7ef131-37ec-4aff-b81b-d6408d8f2c17.png)

execve 函数加载并运行可执行目标文件 filename, 且带参数列表 argv 和环境变量列表 envp。新进程它会覆盖当前进程的地址空间（原进程的数据和代码丢失）, 并且继承了调用 execve 函数时已打开的所有文件，新的程序仍然有相同的 PID 描述符。execve 调用一次并从不返回。

---

## 3、信号

信号是一种更高层的软件形式的异常，它允许进程和内核中断其他程序。例如程序在前台运行时，用户输入 Crtl + C，内核会发送 SIGINT 信号终止该进程组的程序，一个进程可以通过向另一个进程发送 SIGKILL 信号强行终止它。另外，信号还提供了一种机制，当出现底层硬件异常时，通知用户发生了这种异常。例如出现除 0，非法指令，非法内存异常时，内核会发送相应的信号通知用户。

信号处理程序与主程序并发运行，共享同样的全局变量。对这句话的理解是：**主程序运行的同时，信号处理程序也在实时监测信号。当收到某种信号后，主程序转向信号处理程序，待处理完成后再返回主程序**。

一个发出而没有被接收的信号叫待处理信号，一种类型至多有一个待处理信号。当一个进程接收到一个和待处理的某个信号类型相同的信号时，进程会将其丢弃。一个进程可以有选择的阻塞某种信号，当一种信号被阻塞时，进程接收到该类信号后不会立刻处理它，而是将它设置成待处理信号，直到阻塞解除。

### 发送信号

内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。有以下两种原因：

- 内核检测到一个系统事件，比如除零错误或子进程终止。
- 一个进程调用 kill 函数，显示地要求内核发送一个信号给目的进程。

### 信号接收

当内核把进程 p 从内核模式切换到用户模式时，会检查进程 p 未被阻塞的待处理信号的集合。如果集合非空，内核会选择集合中的某个信号 k，强制 p 接收信号 k。每种信号有于其关联的默认行为，如下图：

![image](https://user-images.githubusercontent.com/56211928/146660067-8c90ac2a-518c-4a5a-b8bb-0556010ac4d9.png)

signal 函数可以修改和信号相关联的默认行为（不可以修改 SIGSTOP 和 SIGKILL）

![image](https://user-images.githubusercontent.com/56211928/146660141-c327e588-7724-4dbf-b34e-7287116b7251.png)

signal 函数可以通过下列三种方式来改变和信号 signum 相关联的行为：
 
- 如果 handler SIG_IGN, 那么忽略类型为 signum 的信号。
- 如果 handler SIG_DFL, 那么类型为 signum 的信号行为恢复为默认行为
- 否则，handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为。

下图的示例中，将 SIGINT 信号的行为修改为输出一条消息后终止进程，当用户键入 Ctrl + C 时，会看到终端输出 Caught SIGINT。

![image](https://user-images.githubusercontent.com/56211928/146660249-a37644e0-cb16-4d8d-a724-15baee2597e7.png)

### 阻塞和解除阻塞信号

内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。

- 隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理的信号类型。假设程序捕获了信号 s, 当前正在运行处理程序 S。如果发送给该进程另一个信号 s, 那么直到处理程序 S 返回，s 会变成待处理而没有被接收。
- 显式阻塞机制：应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

![image](https://user-images.githubusercontent.com/56211928/146660390-6302989c-96cb-414d-a173-407ebf1c9275.png)

sigprocmask 函数改变当前阻塞的信号集合。具体的行为依赖于 how 的值：

- SIG_BLOCK: set 中的信号添加到 blocked。
- SIG_UNBLOCK: blocked 中删除 set 中的信号。
- SIG_SETMASK: block=set。

如果 oldset 非空，那么 blocked 位向量之前的值保存在 oldset 中。

使用下述函数对 set 信号集合进行操作： 
- sigemptyset 初始化 set 为空集合。 
- sigfillset 函数把每个信号都添加到 set 中。 
- sigaddset 函数把 signum 添加到 set, sigdelset 从 set 中删除 signum,。
- 如果 signum 是 set 的成员，那么 sigismember 返回 1, 否则返回 0。

### 同步流以避免并发错误

考虑如下代码，它是一个典型的 Unix shell 的结构。父进程在一个全局作业列表中记录着它的当前子进程，每个作业一个条目。 addjob 和 deletejob 函数分别向这个作业列表添加和从中删除作业
当父进程创建一个新的子进程后，它就把这个子进程添加到作业列表中，当父进程在 SIGCHLD 处理程序中回收一个终止的子进程时，它就从作业列表中删除这个子进程。

![image](https://user-images.githubusercontent.com/56211928/146660827-90927176-7abd-4107-af5b-e8eb2e0be4c2.png)

该代码可能会发生以下情况
1) 父进程执行 fork 函数，内核调度新创建的子进程运行，而不是父进程。
2) 在父进程能够再次运行之前，子进程就终止，并且变成一个死进程，使得内核传递一个 SIGCHLD 信号给父进程。
3) 后来，当父进程再次变成可运行但又在它执行之前，内核注意到有未处理的 SIGCHLD，并通过在父进程中运行处理程序接收这个信号。
4) 信号处理程序回收终止的子进程，并调用 deletejob, 这个函数什么也不做，因为父进程还没有把该子进程添加到列表中。
5) 在处理程序运行完毕后，内核运行父进程，父进程从 fork 返回，通过调用 addjob 错误地把（不存在的）子进程添加到作业列表中。

以上的执行结果是在作业条目中出现一个永久的僵死进程。这是一个称为竞争的经典同步错误的示例。main 函数中调用 addjob 和处理程序中调用 deletejob 存在竞争。

以下代码可以保证在子进程被添加到作业列表之后再回收该子进程。主函数在调用 fork 之前，阻塞信号 SIGCHLD，在调用 addjob 之后取消这个阻塞信号。这段代码中，尽管在 addjob 前子进程就终止，主函数仍然会将子进程加入到作业条目中，之后再通过 handler 函数将其回收。注意，子进程继承了它们父进程的阻塞集合，所以必须在调用 execve 之前，解除子进程中的阻塞信号 SIGCHLD（第32行）。

![image](https://user-images.githubusercontent.com/56211928/146661188-d784ebd7-fe82-43bb-98aa-3b7ea6384379.png)

请参照上述“阻塞和解除阻塞信号”中的内容，理解和阻塞信号有关的代码含义。

### 非本地跳转

C 语言提供了一种用户级异常控制流形式，称为非本地跳转, 它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。**它可以理解为在程序某个位置设置一个还原点，之后程序可以在任何时候返回这里**。非本地跳转通过 setjump 和 longjmp 实现。

![image](https://user-images.githubusercontent.com/56211928/146661322-88204ba2-a07c-4ed2-8a1b-28d63041feab.png)

setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回 0。调用环境包括程序计数器、栈指针和通用目的寄存器。注意，setjmp 返回的值不能被赋值给变量，但可以在 switch 或条件测试中使用。longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 调用的返回，并带有非 0 的返回值 retval。其中，setjmp 函数被调用一次，返回多次（第一次调用保存调用环境，之后通过 longjmp 的调用返回），longjmp 只被调用一次而不返回。

非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。以下代码展示了非本地跳转的执行过程。

![image](https://user-images.githubusercontent.com/56211928/146661565-704ebe81-5c03-47b7-a8d1-b68dd9ed9e01.png)
![image](https://user-images.githubusercontent.com/56211928/146661567-4c88fdbc-4010-4f8d-9397-0be6bec06e2d.png)

其运行结果是：Detected an error2 condition in foo。




