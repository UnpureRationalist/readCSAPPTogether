# 第八章

## 1、异常

异常是控制流中的突变，由软件和硬件共同实现。当处理器检测到有事件发生时，会通过一张叫做异常表的跳转表，进行一个间接的过程调用，到一个专门设计用来处理这类事件的操作系统子程序。

![image](https://user-images.githubusercontent.com/56211928/146646389-cc62cd4a-1795-4c55-884e-5cb83a718fcd.png)

当异常处理程序完车呢个处理后，根据引起异常实践的类型，出现以下 3 种情况的一种：

- 处理程序将控制返回给当前指令，即当事件发生时执行的指令。
- 处理程序将控制返回给当前指令的下一条指令。
- 处理程序终止

异常处理类似于过程调用，但有以下几点不同：

- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在前指令后执行的指令）。
- 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如， x86-64 系统会将包含当前条件码的 EFLAGS寄存器和其他内容压入栈中。
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中 而不是压到用户栈中。
- 异常处理程序运行在内核模式下（见 2. 节），这意味 它们对所有的系统资源都有完全的访问权限。

---

### 异常的类别

异常可以分为终端、陷阱、故障和终止 4 类，如下图：

![image](https://user-images.githubusercontent.com/56211928/146646671-f6684a21-151f-43bb-909e-323416db82b4.png)

**中断**

中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。I/O 设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。除了中断之外的异常均是同步发生的。

![image](https://user-images.githubusercontent.com/56211928/146646799-e453bc82-ffe2-44f8-9464-e6d7083bc6a0.png)

**陷阱**

陷阱是有意的异常，是执行一条指令的结果。最典型的陷阱是系统调用。用户程序经常需要向内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 syscall n 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。

![image](https://user-images.githubusercontent.com/56211928/146646954-7858fc54-a37e-4c4e-af55-a83adc60bf67.png)

常见的系统调用如下图：

![image](https://user-images.githubusercontent.com/56211928/146647150-3fae186e-f01c-466b-9953-bbee13045fb8.png)

**故障**

故障由错误情况引起，它可能能够被故障处理程序修正。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程， abort 例程会终止引起故障的应用程序。一个经典的故障是缺页异常。

![image](https://user-images.githubusercontent.com/56211928/146647007-59d38f8b-d23b-4f7c-891d-b0edac1d8523.png)

**终止**

终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。

![image](https://user-images.githubusercontent.com/56211928/146647055-64518147-987d-4c48-b89d-3ae1572113ae.png)

## 2、进程



