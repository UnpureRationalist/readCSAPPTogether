# 第三章04-指针和浮点数.md

## 1、理解指针

指针是 C 语言中的一个核心特色。它们以一种统一的方式，对不同数据结构中的元素产生引用。以下是针对指针的若干理解：

- 每个指针都对应一个类型。这个类型表明该指针指向的是哪一类对象。指针类型不是机器代码中的一部分（个人理解，所有的数据类型都不是机器代码的一部分）；它们是 C 语言提供的一种抽象，帮助程序员避免寻址错误。编译器将不同类型的指针对应为不同长度的寄存器。

![image](https://user-images.githubusercontent.com/56211928/142997280-22d02d5b-8a77-493d-9e5b-68ab1f6f4c41.png)

- 将指针从一种类型强制转换成另一种类型，不改变它的值，其效果是该百年指针运算的伸缩。
- 指针可以指向函数，函数指针的值是该函数机器代码表示中第一条指令的地址。对如下的函数声明，函数指针的用法如下：

![image](https://user-images.githubusercontent.com/56211928/142999119-ee559e58-9617-4c52-98b1-1123b080428b.png)

---
## 2、缓冲区溢出

C 语言对于数组引用不进行任何边界检查，而且局部变量和状态信息（如被保护的寄存器值和返回地址）都存放在栈中。因此，对越界数组元素的写操作会破坏存储在栈中的状态信息，造成严重错误。请看如下的示例：

![image](https://user-images.githubusercontent.com/56211928/143000152-45b5695f-7e62-48fe-81bc-2a1d0a679eb4.png)

对于 gets 函数，它从标准库读入一行，在遇到换行字符时停止。它将字符串复制到参数 s 指明的位置。但它的问题是没有办法确定是否为保存整个字符串分配了足够的空间。上例中，任何长度超过 7 个字符的字符串都会导致越界。检查 echo 的汇编代码如下：

![image](https://user-images.githubusercontent.com/56211928/143001067-7fda4f01-cea9-4a6a-87af-44bc02447f04.png)

相应栈的组织如下：

![image](https://user-images.githubusercontent.com/56211928/143001415-7a406b68-edf7-4e37-a9ad-1155e6c0a5c7.png)

可知，输入字符串的长度在 23 个字符之内都没有严重的后果，但长度大于 23 时，函数返回的值以及更多的内容将被破坏。ret 指令将会跳转到意想不到的位置。

**针对缓冲区溢出的攻击**

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码 (exploit code), 另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行 ret 指令的效果就是跳转到攻击代码。

**对抗缓冲区溢出攻击**

- 栈随机化：栈的位置在程序每次运行时都有变化，使攻击者无法确定攻击代码具体存放的位置。
- 栈破坏检测：在栈中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值，在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否发生了改变，如果是，则程序异常终止。

![image](https://user-images.githubusercontent.com/56211928/143002956-a60870ee-0937-45fa-858f-e89f7522a7f9.png)

- 限制可执行代码区域：通过限制那些内存区域能够存放可执行代码，来减小攻击者向系统中插入可执行代码的能力。

---
## 3、变长栈帧

前面的例子（除了变长数组）中，编译器预先能够确定需要为栈分配多少空间。但对于有些情况，需要的局部存储是变长的。为了管理变长栈帧，x86-64 代码中使用寄存器 %rbp 作为帧指针，也成为基指针。当使用帧指针时，代码首先把 %rbp 的值保存到栈中，然后将 %rsp 赋值给 %rbp，并保持 %rbp 的值不变，利用相对于 %rbp 的偏移来引用栈的局部变量。leave 指令将帧指针恢复到之前的情况，它等价于以下两条指令:

      movq %rbp, %rsp
      popq %rbp

---
## 4、浮点代码

x86-64 浮点数是基于 SSE 或 AVX 的，以下讲述基于 AVX2，即 AVX 的第二个版本。AVX 体系结构允许数据存储在 16 个 YMM 寄存器中，名为 %ymm0 - %ymm15。进行浮点计算时，只使用低 32 位或 64 位（虽然每个寄存器有 256 位）。浮点寄存器名称和使用规则如下：

![image](https://user-images.githubusercontent.com/56211928/143015517-1f0fa518-31a6-44dd-8384-c8a0e33766cd.png)

类似于整形变量，浮点型变量也有相关类型的指令，以下分别介绍。

### 浮点传送指令

![image](https://user-images.githubusercontent.com/56211928/143016022-e0088d79-827f-44bd-9068-802c13cf40fb.png)



