# 第九章

## 1、虚拟内存

虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、 一致的和私有的地址空间。虚拟内存提供了三个重要的能力： 

- 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。
- 它为每个进程提供了一致的地址空间，从而简化了内存管理。
- 它保护了每个进程的地址空间不被其他进程破坏。

虚拟内存是一个实际上不存在的内存系统，它的每个内存页实际上是到物理内存或磁盘的映射。在任意时刻，虚拟页面的集合都分为三个不相交的子集：

### 页表

操作系统为每个进程提供一个独立的页表，**页表将虚拟页映射到物理页**，虚拟地址空间中的每个页在页表中一个固定偏移量处有一个页表条目（PTE）。我们假设每个 PTE 由一个地址有效位和一个 n 位地址字段组成，有效位表明该虚拟页当前是否缓存在 DRAM 中，根据有效位和地址字段的不同，可以将 PTE 分为以下三类：

- 有效位为 0，地址字段为空：虚拟系统还未分配的页，它不会占据任何内存或磁盘的空间。
- 有效位为 0，地址字段不空：未缓存在物理内存中的已分配页，目前存放在磁盘上。
- 有效位为 1：当前以缓存在物理内存中的已分配页。

![image](https://user-images.githubusercontent.com/56211928/147178169-21d50c4e-d522-4bf8-bdab-0a7d5ec8db62.png)

### 地址翻译

CPU 芯片中有专门负责地址翻译的硬件 MMU，CPU 读取进程指令中的虚拟地址，**地址翻译硬件将虚拟地址作为一个索引到页表中查询**，如果页表对应项设置了有效位，则表示该地址的数据已经缓存在内存中，在内存中的物理地址是该页表项的地址字段，CPU 可以到内存（高速缓存）的相应位置读取内容。否则，会触发缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择根据某种策略，选择物理内存中的一页，将页表地址字段对应的磁盘上的内容调入内存中，并修改页表的对应项。下图展示 MMU 如何利用页表进行地址翻译：

![image](https://user-images.githubusercontent.com/56211928/147181803-d4c3078c-70c4-4182-adc6-74e82b1355cc.png)

CPU 中的一个控控制寄存器——页表基址寄存器指向当前页表，n 位的虚拟地址包含两部分，一个 p 位的虚拟页面偏移和一个 n - p 位的虚拟页号，MMU 利用 VPN 来选择适当的页表项（PTE），将 PPN 和 VPO 串联起来，就得到相应的物理地址。

现代操作系统使用按需页面调度的方式，即不会预先从磁盘读取内容到内存，直到发生缺页时才进行调度。局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集或常驻集合。通常，一个程序在稳定状态下不会出现大量的缺页现象。

### 快表（TLB）

每次 CPU 产生一个虚拟地址， MMU 就必须查阅一个 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。许多系统都试图消除即使是这样的开销，它们在 MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器（TLB）。TLB 是一个虚拟寻址的缓存，原理与 cache 相同，它每一行保存着一个由单个页表项（PTE）组成的块（cache 中每项保存固定大小的内存块，通常是 64 字节）。

### 多级页表

多级页表用来压缩页表大小。这种方法从两个方面减少了内存要求（假设一个具有二级页表的系统）。

- 第一，如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在，这是一种巨大的潜在节约。
- 第二，只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建、调入或调出二级页表，这就减少了主存的压力，只有最经常使用的二级页表才需要缓存在内存中。

一个具有 k 级页表层次结构的示意图如下：

![image](https://user-images.githubusercontent.com/56211928/147185326-bdda256f-a415-4de3-82e0-d2283899224e.png)

虚拟地址被划分成为 k 个 VPN 和 1 个 VPO。每个 VPN i 都是一个到第 i 级页表的索引。第 j 级页表中的每PTE, 都指向第 j + 1 级的某个页表的基址（第 1 级页表的基址有页表基址寄存器给出）。第 k 级页表中的每个 PTE 包含某个物理页面的实际地址 PPN, 或者一个磁盘块的地址。为了构造物理地址，在能够确定 PPN之前，MMU 必须访问 k 个 PTE。但由于 TLB 的存在，这种代价是可以接收的。

### Linux 虚拟内存

Linux 为每个进程维护一个单独的虚拟地址空间，如下图：

![image](https://user-images.githubusercontent.com/56211928/147191146-9aaa9b0a-dbf4-430f-a1e3-a6bc721b55d6.png)

内核虚拟内存包含内核中的代码和数据结构，内核虚拟内存的某些区域被映射到所有进程共享的物理页面，即不同进程的虚拟内存映射到同样的物理内存中。例如，每个进程共享内核的代码和全局数据结构。内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。

内核为系统中的每个进程维护一个单独的任务结构 task_struct。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如 PID、指向用户栈的指针、可执行目标文件的名字，以及程序计数器）。当 MMU 在翻译某个虚拟地址时发生了缺页，内核的缺页处理程序将通过 task_struct 中的某些数据（mm_struct 中的 mmap）判断该虚拟地址是否合法（该虚拟地址是否在某个结构定义的区域内，访存权限的判断）。

## 2、内存映射

## 3、动态分配内存
