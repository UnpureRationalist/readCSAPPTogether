# 第五章

## 1、定义 CPE

引入度量标准每元素的周期数——CPE，作为一种表示程序性能并指导代码改进的方法。CPE 需要通过对某段程序使用不同的元素数量重复执行，再利用最小二乘法进行估计。一个估算 CPE 的示例图如下：

![image](https://user-images.githubusercontent.com/56211928/144694730-ba6664c1-ddd4-49df-8021-44537c008579.png)

通过最小二乘法拟合，得到 psum1 = 368 + 9.0n，psum2 = 368 + 6.0n，故知 psum1 和 psum2 的 CPE 分别是 9.0 和 6.0。

## 2、理解现代处理器

在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。现代处理器采用超标量技术，即利用多个执行相同操作的功能部件，再每个时钟周期执行多个操作。流水线采用乱序方式，指令的执行顺序不一定于机器程序中的顺序一致。

### 2.1 功能单元的性能

以 Intel Core i7 Haswell 为例，它执行某些算术运算所需的时钟周期如下：

![image](https://user-images.githubusercontent.com/56211928/144695023-1dc61a53-a1e9-407a-8a61-90c9126d1afd.png)

对于每个操作，由以下三种变量来刻画：

- 延迟 (latency), 它表示完成运算所需要的总时间
- 发射时间 (issue time), 它表示两个连续的同类型的运算之间需要的最小时钟周期数
- 容量 (capacity), 它表示能够执行该运算的功能单元的数量

发射时间为 1 的功能单元被称为是完全流水化的，每个周期可以开始一个新的运算。在没有数据冲突的情况下，完全流水化的指令可以认为在 1 个周期内即可执行完毕。

对于一个容量为 C，发射时间为 I 的操作来说，处理器可能获得的最大吞吐量为每个时钟周期 C / I 个操作。

### 2.2 程序性能上限

- **功能界限**给出了任何必须严格按照顺序完成运算的函数所需要的最小 CPE 值，等于该操作的延迟数。
- **吞吐量界限**给出了理论上 CPE 的最小值，等于容量除以发射时间。

对于整数和浮点数的一些操作，Intel Core i7 Haswell 的性能如下：

![image](https://user-images.githubusercontent.com/56211928/144695409-6f056f5b-182d-46d0-95c7-e61997b1c980.png)

## 3、程序优化示例

### 3.1 基本优化

以下代码对数组 v 执行一系列操作，将结果存储在 dest 中，其中 IDENT 为 0 或 1，分别对应 OP 为 + 或 * ：

![image](https://user-images.githubusercontent.com/56211928/144695491-86c69756-4d05-4fbe-928a-8823767178dc.png)

以上代码的效率并不高，以下对其执行一系列代码变化：

- 消除循环的低效率：将循环内部的 i < vec_length(v) 外提。
- 减少过程调用：利用 get_vec_start 获取数组首地址，无需使用循环内部的 get_vec_element 来获取数组元素。
- 消除不必要的内存引用：创建一个新的临时变量 acc，迭代时对 acc 进行更新，最后将 acc 赋给 \*dest

现在得到如下代码：

![image](https://user-images.githubusercontent.com/56211928/144696067-1bfd0863-2620-4a14-90b9-f1d842247e6f.png)

各个版本代码的效果如下：

![image](https://user-images.githubusercontent.com/56211928/144709427-b5916278-ae63-42ee-a4ef-55dacc2e7539.png)
![image](https://user-images.githubusercontent.com/56211928/144709438-14f2608c-18c3-455e-9efd-c1d607ee7d4b.png)
![image](https://user-images.githubusercontent.com/56211928/144709444-f97b33fc-da93-43ab-bf5f-c8e591db899e.png)

combine4 的结果已经接近功能界限，接下来，试图利用 cpu 内部特性进行优化。

### 3.2 处理器操作的抽象模型

程序的数据表示是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的关键路径, 这是执行一组机器指令所需时钟周期数的一个下界。

对于形成循环的代码片段，可以将访问到的寄存器分为 4 类：

- 只读：寄存器只用作源值，在循环中不会被修改。
- 只写：寄存器只作为数据传送的目的。
- 局部：寄存器在循环内部被修改和使用，但迭代与迭代之间不相关。
- 循环：寄存器既作为源值，有作为目的，并且一次迭代中产生的值会在另一次迭代中用到。

**循环寄存器之间的操作链决定了限制性能的数据相关**

观察以下代码：

![image](https://user-images.githubusercontent.com/56211928/144709796-093ee226-1895-4daf-b8a0-e45684ccd2f1.png)

其中，rax 是只读存储器，条件码寄存器是局部寄存器，rdx 和 xmm0 是循环寄存器。如果只观察循环寄存器值的变化，可做出如下示意图：

![image](https://user-images.githubusercontent.com/56211928/144709902-6a2e26e3-dd91-4af5-8841-978237398e6f.png)

由此形成的关键路径如下：

![image](https://user-images.githubusercontent.com/56211928/144709929-f7ee32fe-8b49-4e96-9d1e-dca8711e31e1.png)

程序有两条数据相关链，分别对应于 mul 和 add 对程序值 acc 和 data + i 的修改。假设浮点乘法延迟为 5 个周期，而整数加法延迟为 1 个周期，则左边的链会形成关键路径，需要 5n 个周期执行。

### 3.3 利用 cpu 的性能进一步优化程序

- 循环展开：通过增加每次迭代计算的元素的数量，减少循环的迭代次数。2 * 1 的循环展开如下：

![image](https://user-images.githubusercontent.com/56211928/144710418-6cc60683-34e9-476d-953f-6b76f29d82d0.png)

效果不佳，因为程序已经达到了延迟界限，展开后的程序中，每次迭代仍然需要对变量 acc 进行两次更新，对于乘法操作而言，其关键路径上仍然是 n 个 mul 操作。

- 提高并行性：在 2 * 1 循环展开的基础上，建立多个中间变量，提高并行性。2 * 2 的循环展开如下：

![image](https://user-images.githubusercontent.com/56211928/144710747-dfdac28c-0b79-4d2e-ad56-921653dc3bb9.png)

只观察循环寄存器值的变化，可做出如下示意图：

![image](https://user-images.githubusercontent.com/56211928/144710776-1c706e81-f754-4e3c-bfc0-732bb7588324.png)

由此形成的关键路径如下：

![image](https://user-images.githubusercontent.com/56211928/144710785-6618807d-4fb3-457b-8475-3908eb2f00a8.png)

这种情况的 CPE 得到近 2 倍的提升。这是因为在前面 2 * 1 的循环展开中，我们将累计值放在 1 个 acc 中。






