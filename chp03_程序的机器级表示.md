# 第 3 章 程序的机器级表示

本章内容基于 x86-64 汇编语言。

主要内容包括：

- C 语言、汇编代码与机器代码之间关系
- 介绍 x86-64 细节，包括数据的表示和处理以及控制的实现
- 介绍如何实现 C 语言的控制结构
- 介绍过程的实现，包括程序如何维护运行栈以支持过程间数据和控制的传递、局部变量的存储等
- 介绍如何在机器级实现数组、结构、联合这样的数据结构
- 讨论内存访问越界问题、缓冲区溢出攻击问题
- GDB 调试技巧

## 3.1  历史观点

Intel 处理器系列俗称 x86 。



## 3.2 程序编码

1. 机器级代码包括的处理器状态：

   - 程序计数器（PC）：在 x86-64 中用 `%rip` 表示
   - 整数寄存器文件：16 个 64 位寄存器
   - 条件码寄存器：保存最近执行的算术或逻辑运算的状态信息
   - 一组向量寄存器：可存放一个或多个整数或浮点值

2. 代码示例：

   `010-mstore.c 源文件` 

   ```c
   /* $begin 010-mstore-c */
   long mult2(long, long);
   
   void multstore(long x, long y, long *dest) {
       long t = mult2(x, y);
       *dest = t;
   }
   /* $end 010-mstore-c */
   ```

   使用 ` gcc .\010-mstore.c -Og -S` 命令编译，得到如下汇编代码：

   ```assembly
   	.file	"010-mstore.c"
   	.text
   	.globl	multstore
   	.type	multstore, @function
   multstore:
   .LFB0:
   	.cfi_startproc
   	pushq	%rbx		# 表示将寄存器 %rbx 的内容压入程序栈中
   	.cfi_def_cfa_offset 16
   	.cfi_offset 3, -16
   	movq	%rdx, %rbx
   	call	mult2
   	movq	%rax, (%rbx)
   	popq	%rbx
   	.cfi_def_cfa_offset 8
   	ret
   	.cfi_endproc
   .LFE0:
   	.size	multstore, .-multstore
   	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
   	.section	.note.GNU-stack,"",@progbits
   
   ```

   使用 `gcc -Og -c 010-mstore.c` 命令得到目标代码文件 `010-mstore.o` ，为二进制文件。

   使用反汇编器查看机器语言对应汇编代码，命令：`objdump -d 010-mstore.o` ，输出如下：

   ```assembly
   
   010-mstore.o：     文件格式 elf64-x86-64
   
   
   Disassembly of section .text:
   
   0000000000000000 <multstore>:
      0:   53                      push   %rbx
      1:   48 89 d3                mov    %rdx,%rbx
      4:   e8 00 00 00 00          callq  9 <multstore+0x9>
      9:   48 89 03                mov    %rax,(%rbx)
      c:   5b                      pop    %rbx
      d:   c3                      retq
   ```

   其中，左边为机器代码，右边为对应的汇编指令。其中，x 在 `%rdi` 寄存器；y 在 `%rsi` 寄存器；dest 在 `%rdx` 寄存器。



## 3.3 数据格式

Intel 中术语 ”字（word）” 表示 16 位；32 位称为 “双字（double words）” ；64 位称为 “四字（quad word）”。

![](img/fig3_1.png)

后缀 `l` 表示双字，因为 32 数被看作 “长字（long word）”。`l` 也表示双精度浮点数。



## 3.4 访问信息

x86-64 处理器有 16 个 64 位通用目的寄存器。

![](img/fig3_2.png)

### 3.4.1 操作数指示符

操作数有三种类型：

1. 立即数：在 ATT 格式汇编中，书写格式为 \$ 后面跟着一个用标准 C 语言表示法的常数，如 `$-577` 或 `$0x1F` 。
2. 寄存器：表示某个寄存器的内容。
3. 内存引用：根据计算出来的地址（通常称为有效地址）访问某个内存位置。

寻址模式：

![](img/fig3_3.png)

### 3.4.2 数据传送指令

1. MOV 类指令：将 source（S）值写入 destination（D）

   ![](img/fig3_4.png)

   注意：将一个值从一个内存位置复制到另一个内存位置，需要两条指令：先将源操作数加载到寄存器；再将寄存器值写入目的地址。

   其中，`movabsq` 指令用途是将 64 位立即数传送到寄存器中。常规的 `movq` 指令只能将 32 位补码数字作为立即数，然后将其符号扩展得到 64 位值，放到目的位置。

2. MOVZ 类指令与 MOVS 类指令：分别将目的地址中剩余字节填 0 和进行符号扩展来填充

   ![](img/fig3_6.png)

   

### 3.4.3 数据传送示例

C 代码：

```c
/* $begin 050-exchange-c */
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
/* $end 050-exchange-c */
```

汇编代码：

```assembly
	.file	"050-exchange.c"
	.text
	.globl	exchange
	.type	exchange, @function
exchange:
	movq	(%rdi), %rax
	movq	%rsi, (%rdi)
	ret
	.size	exchange, .-exchange
	.ident	"GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
	.section	.note.GNU-stack,"",@progbits

```

其中，xp 存储在 `$rdi` ；y 存储在 `$rsi` 。



### 3.4.4 压入和弹出数据

栈指针 `$rsp` 保存着栈顶元素的地址。x86-64 中，栈向低地址增长。

![](img/fig3_8.png)



## 3.5 算术和逻辑操作

常用指令见下图。其中，除了 `leaq` 指令外，其它指令都有不同位宽的变种。

![](img/fig3_10.png)

### 3.5.1 加载有效地址

leaq 指令。常用来执行简单的算术运算。

C 代码：

```c
long scale(long x, long y, long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}
```

对应汇编代码：（x in `$rdi`  ; y in `%rsi` ; z in `%rdx` ）

```assembly
scale:
	leaq	(%rdi,%rsi,4), %rax		# x + 4*y
	leaq	(%rdx,%rdx,2), %rdx		# y + 2*z
	leaq	(%rax,%rdx,4), %rax		# x + 4*y + 4*(z + 2*z) = x + 4*y + 12*z
	ret
```



### 3.5.2 一元和二元操作

- 一元操作：只有一个操作数，既是源操作数又是目的操作数
- 二元操作：第二个操作数既是源操作数又是目的操作数。第一个操作数可以是立即数、寄存器或者内存位置；第二个操作数可以是寄存器或内存地址。当第二个操作数为内存地址时，处理器必须先从内存读出值，执行操作，然后再把结果写回内存。



### 3.5.3 移位操作

先给出移位量；再给出要移位的数。

- 移位量：要么为立即数；要么必须放在 `%cl` 寄存器中。对于 w 位长的数据而言，真正的移位量由 `%cl` 寄存器的低 m 位决定，其中 2^m^ = w ，高位会被忽略
- 右移分为算术右移 `SAR` 和逻辑右移 `SHR` 
- 目的操作数可以位寄存器或者内存位置



### 3.5.4 特殊的算术操作

16 个字节的数称为八字（oct word）。相关乘除运算指令如下：

![](img/fig3_12.png)

1. 乘法指令
   - imulq 指令：”双操作数“ 乘法指令
   - ”单操作数“ 乘法指令：要求一个参数必须在寄存器 `%rax` 中；另一个源操作数指令给出。乘积高 64 位存放在 `%rdx` 寄存器中；低 64 位存放在 `%rax` 寄存器中
     1. 无符号乘法指令 `mulq` 
     2. 补码乘法指令 `imulq` 
2. 除法指令
   - 有符号除法指令 `idivl` ：将寄存器 `%rdx` （高 64 位）和寄存器 `%rax` （低 64 位）中的 128 位数作为被除数；除数作为指令的操作数给出。指令将商存储在寄存器 `%rax` 中；余数存储在寄存器 `%rdx` 中
   - 对于 64 位除法来说，被除数也是 64 位的值。则应该将这个值存放在 `%rax` 中，`%rdx` 寄存器将根据为有符号运算或者无符号运算设置为符号位或者全 0。对于有符号运算，这个操作可以由指令 `cqto` 完成。`cqto` 指令不需要任何操作数，它隐含读出 `%rax` 寄存器的符号位并将它复制到 `%rdx` 的所有位



## 3.6 控制

### 3.6.1 条件码

CPU 中还有一组单个位的条件码寄存器，用于描述最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支。常用条件码有：

- CF :  进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出
- ZF :  零标志。最近的操作得出的结果为 0
- SF :  符号标志。最近的操作得到的结果为负数
- OF :  溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出

`leaq` 指令不改变任何条件码。

除了图 3-10 中指令外，还有两类指令会设置条件码而不改变任何其他寄存器：

![](img/fig3_13.png)

其中，CMP 指令除了只设置条件码不改变目的寄存器之外，与 SUB 命令的行为一致。TEST 指令行为与 AND 指令一样，除了其设置条件码而不改变目的寄存器值。



### 3.6.2 访问条件码

通常不会直接读取条件码，常用的使用方式有以下三种：

1. 根据条件码某种组合，将某个字节设置为 0 或 1：SET 指令，具体见下图：

   ![](img/fig3_14.png)

   其中，这些指令的后缀代表不同的条件，如：setl 表示 set less；setb 表示 set below。

   其目的操作数是低位单字节寄存器元素之一或者一个字节的内存地址。为了得到 32 或 64 位的结果，必须要对高位清零。

2. 条件跳转到程序某个其他部分

3. 有条件地传送数据



### 3.6.3 跳转指令

`jmp` 指令，通常后面为 label 。它可以是直接跳转（label 指出），即跳转目标作为指令的一部分编码；也可以是间接跳转（‘*’ 后面跟一个操作数指示符，如：`jmp *%rax` 与 `jmp *(%rax)` 分别以寄存器值和内存值作为跳转目标），即跳转目标是从寄存器或内存地址读出的。

![](img/fig3_15.png)

上图中除了 `jmp` 指令都是有条件的，条件跳转只能是直接跳转。



### 3.6.4 跳转指令的编码































