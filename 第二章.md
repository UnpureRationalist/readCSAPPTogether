**1、指针**

  C编译器把每个指针和类型信息联系起来，根据指针类型，生成不同的机器码访问指针所指位置的值。
  使用一个字节类型的指针`typedef unsigned char *byte_pointer`，能够查看一个变量在内存当中的详细存储内容。
  请参见`字节指针.cpp`
  
**2、字节顺序**

    小端法：最低有效字节在最前面————目前计算机中使用的方法。
    大端法：最高有效字节在最前面————符合阅读习惯。
    
**3、整数表示**

- 补码最高有效位的权重为 -x<sub>w-1</sub> * 2<sup>w-1</sup>，其余位和原码表示的权值相同。
- 几种常见的数值：

    2<sup>w</sup>：取模时用到，保留w位有效值
    
    2<sup>w</sup> - 1：w位变量能表示的最大值
    
    2<sup>w-1</sup>：第w位的权重
    
    2<sup>w-1</sup> - 1：w位有符号数能表示的最大值
    
- 有符号与无符号整数转换时，保持位值不变。但浮点数和整数转换时，会根据变量的存储规则改变位值。请参见`字节指针.cpp`
- 将short转换成unsigned时，先进行位扩展，再进行符号转换。unsigned a = short(-1)，得到结果为2<sup>32</sup> - 1。
- 补码加法:

![image](https://user-images.githubusercontent.com/56211928/141666234-c5f8f877-7154-41fd-a311-962ca0825b3c.png)

      可以这样理解：对于两个正数x,y，最高位的权重为2^(w-1)，如果发生溢出，最高位权重变成-2^(w-1)，故实际结果为x + y - 2^w，负数同理
      
![image](https://user-images.githubusercontent.com/56211928/141666298-6e8bb229-e57a-4f1a-ba59-3635a0c1a010.png)

- 计算补码的非（可以理解为计算相反数）

      1、补码取反加一。
      2、固定最右侧的1，其左侧所有位取反。
        eg：补码11001000 -> 源码00111000
 
 - 对于整数乘法，C语言编译器可以利用移位、加法、减法的组合来消除乘以常数的情况。
 - 对于整数除法（除以2的幂），直接移位导致向下舍入。可以利用(x + (1 << k)) >> k得到向上舍入（对于负数应该向上舍入）。

**3、浮点数**


      

  
  
