# 第十章

## 1、Unix I/O

在 Linux 中，所有的 I/O 设备（如网络、磁盘、终端）都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：

- 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。
- 改变当前文件位置：对于每个打开的文件，内核保持着一个文件位置 k，初始为 0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为 k。
- 读写文件：一个读操作就是从文件复制 n > 0 个字节到内存，从当前文件位置开始，然后将 k 增加到 k + n。给定一个大小为 k 字节的文件，当 k ≥ m 时执行读操作会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的 EOF 符号。类似地，写操作就是从内存复制 n > 0 个字节到一个文件，从当前文件位置开始，然后更新 k。
- 关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

Linux Shell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为 0）、标准输出（描述符为 1）和错误标准（描述符为 2）。

## 2、文件

每个 Linux 文件都有一个类型类表明它在系统中的角色。

- 普通文件：包含任意数据，应用程序常常要区分文本文件和二进制文件，文本文件是只含有 ASCII 或 Unicode 字符的普通文件；二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。
- 目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目，“.”是到该目录自身的链接，以及“..”是到目录层次结构中父目录的链接。
- 套接字：用来与另一个进程跨网络通信的文件。
- 其他文件：字符设备、块设备、符号链接等。

## 3、工作路径

作为进程上下文的一部分，每个进程都有一个当前工作目录来确定其在目录层次结构中的当前位置。工作路径分为绝对路径和相对路径。

- 绝对路径：以一个斜杠开始，表示从根节点开始的路径，如 /home/droh/hello.c。
- 相对路径：以文件名开始，表示从当前工作目录开始的路径。假设 /home 目录下包含 droh 和 bryant 两个目录，其中 hello.c 在 droh 目录下。如果 /home/droh 是当前工作目录，则 hello.c 的相对路径名就是 ./hello.c。如果 /home/bryant 是当前工作目录，那么相对路径名就是 ../droh/hello.c。

## 4、共享文件

内核用三个相关的数据结构来表示打开的文件。

- 描述符表：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。
- 文件表：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数（即当前指向该表项的描述符表项数），以及一个指向 v-node 表中对应表项的指针。 关闭一个描述符会减少相应的文件表表项中的引用计数。当某个表项引用计数为 0 时，内核将其删除。
- v-node 表：同文件表一样，所有的进程共享这张 v-node 表。每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。

### 经典情况

如下图的示例，描述符通过不同的打开文件表表项来引用两个不同的文件。这是一种典型的情况，没有共享文件，并且每个描述符对应一个不同的文件。

![image](https://user-images.githubusercontent.com/56211928/147381772-504363d3-822f-45cf-a4ef-e24a6d7794fb.png)

### 多个描述符 -> 一个 v-node

多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，以同一个 filename 调用 open 函数两次，就会发生这种情况。关键思想是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。

![image](https://user-images.githubusercontent.com/56211928/147381971-ea994f92-6ecd-44bf-a45a-f6dc4bc202ee.png)

### 多个描述符 -> 一个文件表

对于父子进程的文件共享，假设在调用 fork 之前，父进程有上述经典情况所示的打开文件，则调用 fork 后的情况如下图，子进程有一个父进程描述符表的副本，父子进程共享相同的打开文件表集合，因此共享相同的文件位置。

![image](https://user-images.githubusercontent.com/56211928/147381874-5a4d8b0f-1051-4267-b652-3f2c59bea432.png)
