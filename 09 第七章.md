# 第七章

本章知识点较凌乱，无法系统总结，故此处只记录一些个人认为的重点。

## 1、静态链接

静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载运行的可执行目标文件作为输出。

### 可重定位目标文件

一个典型的 ELF 可重定位文件格式如下，ELF 头以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字和大小的顺序等信息，夹在 ELF 头和节头部表之间的都是节。

![image](https://user-images.githubusercontent.com/56211928/146772788-4d100a3d-be58-483f-8196-4a2c748c11f7.png)

夹再 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：

- .text：已编译程序的机器代码
- .radata：只读数据，如 printf 语句中的格式串和开关语句的跳转表。
- .data: 已初始化的全局和静态变量。局部变量在运行时被保存在栈中，既不出现在 .data 节中，也不出现在 .bss 节中。
- .bss: 未初始化的静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。
- .symtab: 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。.syrntab 符号表不包含局部变量的条目。
- .rel.text: 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。
- .rel.data: 被模块引用或定义的所有全局变最的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。
- .line: 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。
- .strtab: 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。

---

### 符号和符号表

每个可重定位目标模块 m 都有一个符号表，即上述的 .symtab，它包含 m 定义和引用的符号的信息。在链接器上下文中，有三种不同的符号：

- 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。
- 由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变最。
- 只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。

注意，本地程序中的非静态局部变量不包含在 .symtab 中。

符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。.symtab 中包含 ELF 符号表。这张符号表包含一个条目的数组。

![image](https://user-images.githubusercontent.com/56211928/146780127-7a54be8c-e3ac-4887-bce2-89fa68be659b.png)

name 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。value 是符号的地址。对于可重定位的模块来说，value 是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址。size 是目标的大小（以字节为单位）。type 通常要么是数据，要么是函数。binding 字段表示符号是本地的还是全局的。

**每个符号都被分配到目标文件的某个节，由 section 字段表示**，该字段也是一个到节头部表的索引。有三个特殊的伪节, 它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号； UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号； COMMON 表示还未被分配位置的未初始化的数据目标。注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。

在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。根据强弱符号的定义， Linux 链接器使用下面的规则来处理多重定义的符号名：
- 规则1：不允许有多个同名的强符号。
- 规则 2: 如果有一个强符号和多个弱符号同名，那么选择强符号。
- 规则 3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

考虑 COMMON 和 .bss 的区别：

- COMMON 表示未初始化的全局变量
- .bss 表示未初始化的静态变量，以及初始化为 0 的全局或静态变量。

这样做的目的是，当编译器在翻译某个模块时，遇到一个弱全局符号，比如说 x, 它并不知道其他模块是否也定义了 x, 如果是，它无法预测链接器该使用 x 的多重定义中的哪一个。所以编译器把 x 分配成COMMON, 把决定权留给链接器。另一方面，如果 x 初始化为 0, 那么它是一个强符号，所以编译器可以很自信地将它分配成 .bss 。类似地，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成 .data 或 .bss。

---

### 静态库

静态库是将相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。在 Linux 系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 .a 标识。

假如有可重定位目标文件 addvec.o 和 multvec.o，要创建一个静态库，可以使用 ar 工具：
 
  linux> ar rcs libvector.a addvec.o multvec.o
  
要使用这个库，使用如下命令：

  linux> gcc -static -o main main.o ./libvector.a
  
-static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需进一步的链接。**默认情况下，gcc 会采用动态链接，每个 c 程序都会动态链接 libc.so 库**。下图概括了静态库的链接过程（libc.a 是自动链接的）

![image](https://user-images.githubusercontent.com/56211928/146794305-581dd396-62d5-48d8-b692-7a4b7314ab3c.png)

## 2、可执行文件

以下是一个典型的 ELF 可执行文件：

![image](https://user-images.githubusercontent.com/56211928/146791044-cfa84dd2-d10c-430e-a15e-d694530d5df7.png)

.init 节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件完全链接的（已被重定位）所以它不再需要 .rel 节。要运行可执行目标文件 prog, 我们可以在 Linux shell 的命令行中输入它的名字：

  linux> ./prog
 
每个 Linux 程序都有一个运行时内存映像，如下图：

![image](https://user-images.githubusercontent.com/56211928/146795529-8ddbf267-7ad5-4719-bdfe-b804cec80a49.png)

代码段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。堆后面的区域是为共享模块保留的，用户栈总是从最大的合法用户地址 2<sup>48</sup> - 1 开始，向较小内存地址增长。栈往上的区域，是为内核中的代码和数据保留的，即操作系统驻留在内存的部分。

## 3、动态库

共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的，共享库也称为共享目标，在 Linux 系统中通常用 .so 后缀来表示。

在任何给定的文件系统中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。另外，在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。

假设有源文件 addvec.c multvec.c，可以使用如下代码生成动态链接库：
  
  linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c
  
-fpic 选项指示编译器生成位置无关代码（所有共享文件必须是位置无关的），-shared 选项指示链接器创建一个共享的目标文件。要链接这个共享库，使用如下命令：

  linux> gcc -o main main.c ./libvector.so

这样就创建了一个可执行目标文件 main, 而此文件的形式使得它在运行时可以和 libvector.so 链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。注意：没有任何 libvector.so 的代码和数据节真的被复制到可执行文件 main 中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。另外，不指定静态链接时，libc.so 是每个 C 程序会默认链接的。下图概括了动态库的连接过程：

![image](https://user-images.githubusercontent.com/56211928/146794398-321cc3a2-a7f6-4d7b-8ece-772ce5db5a53.png)

## 4、相关实验
